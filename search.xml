<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android-Studio：使用Gradle构建不同版本的APP(构建变体)</title>
    <url>/2016/05/25/Android-Studio%EF%BC%9A%E4%BD%BF%E7%94%A8Gradle%E6%9E%84%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84APP(%E6%9E%84%E5%BB%BA%E5%8F%98%E4%BD%93)/</url>
    <content><![CDATA[<p>Android Studio（我使用的Studio版本是2.0）中有一个构建变体的功能，默认位于左下角</p>
<img src="/2016/05/25/Android-Studio%EF%BC%9A%E4%BD%BF%E7%94%A8Gradle%E6%9E%84%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84APP(%E6%9E%84%E5%BB%BA%E5%8F%98%E4%BD%93)/1.webp" class="">
<p>那这个功能是做什么用的呢，一般来说我们在做项目的时候，可能有这样的需求，一个项目中需要有不同版本，比如说免费版，收费版，周年庆版啦等等，这些版本大部分功能和模块是一样的只是部分不同，以前可能是通过svn或者git上建立分支来进行版本控制，但维护起来很麻烦。所以构建变体这个功能用官方的说法就是你<strong>可以在一个项目里面构建不同的版本</strong>，对，而且打包的时候可以一次性打包所有版本，是不是超级爽。英语好的同学可以看官方的教程<a href="https://developer.android.com/studio/build/build-variants.html">Configure Build Variants</a>。</p>
<span id="more"></span>

<h2 id="配置Product-Flavors"><a href="#配置Product-Flavors" class="headerlink" title="配置Product Flavors"></a>配置Product Flavors</h2><p>第一步，在moudle中的build文件中配置Product Flavors</p>
<pre><code class="java">android &#123;
    defaultConfig &#123; ... &#125;
 //... 
    productFlavors &#123;
        free &#123;
            applicationId &quot;cc.abto.free&quot;
            versionCode 125
            versionName &quot;2.3.5&quot; + &quot;&quot;

        &#125;
        charge &#123;
            applicationId &quot;cc.abto.charge&quot;
            versionCode 7
            versionName &quot;1.0.7&quot; + &quot;&quot;

        &#125;
    &#125;
//...
&#125;
</code></pre>
<p>上面的代码中，我们创建了两个版本，一个free版和一个charge版，其中defaultConfig 为默认值，productFlavors {}会复写所有可以复写的值。配置好之后我们就可以<strong>Sync Project</strong>一下啦，然后就可以在左下角的Build Variants工具栏上选择版本啦。</p>
<img src="/2016/05/25/Android-Studio%EF%BC%9A%E4%BD%BF%E7%94%A8Gradle%E6%9E%84%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84APP(%E6%9E%84%E5%BB%BA%E5%8F%98%E4%BD%93)/2.webp" class="">
<p>第二步，我们还需要给每个版本创建对应的文件夹，点击src文件夹右键</p>
<img src="/2016/05/25/Android-Studio%EF%BC%9A%E4%BD%BF%E7%94%A8Gradle%E6%9E%84%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84APP(%E6%9E%84%E5%BB%BA%E5%8F%98%E4%BD%93)/3.webp" class="">
<p>文件夹的名称和productFlavors {}中的名称对应。然后再在各个文件下常见相应的java和res以及AndroidManifest等文件夹或文件。当然手动创建这些文件夹很麻烦（我就是这么懒），我们可以通过新建一个Activity来创建相关的文件夹。然后在Acitvity的创建界面，我们选择放置在哪一个版本。</p>
<img src="/2016/05/25/Android-Studio%EF%BC%9A%E4%BD%BF%E7%94%A8Gradle%E6%9E%84%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84APP(%E6%9E%84%E5%BB%BA%E5%8F%98%E4%BD%93)/4.webp" class="">
<p>如上图所示，当当当，需要的文件夹就都创建完成了，Build Variants选择版本和创建相应文件夹之后，在android目录结构下就只能看到这个版本的文件</p>
<img src="/2016/05/25/Android-Studio%EF%BC%9A%E4%BD%BF%E7%94%A8Gradle%E6%9E%84%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84APP(%E6%9E%84%E5%BB%BA%E5%8F%98%E4%BD%93)/5.webp" class="">
<p>然后你就可以针对这个版本做开发啦，当你要开发另一个版本时，再在Build Variants选择相应的版本，怎么样，是不是很赞，给了这么图是因为这东西跟理论不同，希望能尽量的直观点。</p>
<h3 id="不同的Manifest需求"><a href="#不同的Manifest需求" class="headerlink" title="不同的Manifest需求"></a>不同的Manifest需求</h3><p>每个版本都可以有自己的清单文件，Manifest可以通过Merge的方式合并多个Manifest源。也就是说，manifest的merge会将每个元素及其子元素的节点和属性进行合并。但是每个版本的manifest之间是不会合并的。</p>
<h3 id="不同的依赖"><a href="#不同的依赖" class="headerlink" title="不同的依赖"></a>不同的依赖</h3><p>你也可以给不同的版本使用不同的依赖，在build.gradle中，使用Flavor名+Compile来规定特定Flavor所需依赖。</p>
<pre><code class="java">dependencies &#123;
    //...
    freeCompile &#39;com.android.support:appcompat-v7:23.3.0&#39;
    chargeCompile  &#39;com.android.support:design:23.3.0&#39;
&#125;
</code></pre>
<h3 id="不同ProGuard需求"><a href="#不同ProGuard需求" class="headerlink" title="不同ProGuard需求"></a>不同ProGuard需求</h3><p>当然也可以针对版本做不同的混淆要求</p>
<pre><code class="java">android &#123;
    buildTypes &#123;
        release &#123;
            minifyEnabled true
            proguardFile getDefaultProguardFile(&#39;proguard-android.txt&#39;)
        &#125;
    &#125;

    productFlavors &#123;
        flavor1 &#123;
        &#125;
        flavor2 &#123;
            proguardFile &#39;some-other-rules.txt&#39;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>最后，我们在打包发布的时候可以在列表中选择所有版本，gradle就会一次性打包好所有版本。</p>
<img src="/2016/05/25/Android-Studio%EF%BC%9A%E4%BD%BF%E7%94%A8Gradle%E6%9E%84%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84APP(%E6%9E%84%E5%BB%BA%E5%8F%98%E4%BD%93)/6.webp" class="">
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中AIDL的使用详解</title>
    <url>/2016/06/09/Android%E4%B8%ADAIDL%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>为了说的深入浅出一点，我们先从AIDL的作用和使用说起，然后再开始介绍一些概念和工作原理。</p>
<h2 id="AIDL用来做什么"><a href="#AIDL用来做什么" class="headerlink" title="AIDL用来做什么"></a>AIDL用来做什么</h2><p>AIDL是Android中<strong>IPC（Inter-Process Communication）</strong>方式中的一种，AIDL是<strong>Android Interface definition language</strong>的缩写，对于小白来说，AIDL的作用是让你可以在自己的APP里绑定一个其他APP的service，这样你的APP可以和其他APP交互。<br> <span id="more"></span></p>
<h2 id="AIDL的使用"><a href="#AIDL的使用" class="headerlink" title="AIDL的使用"></a>AIDL的使用</h2><p>在android studio 2.0里面使用AIDL，因为是两个APP交互么，所以当然要两个APP啦，我们在第一个工程目录右键</p>
<img src="/2016/06/09/Android%E4%B8%ADAIDL%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/1.webp" class="">

<p>输入名称后，sutido就帮我们创建了一个AIDL文件。</p>
<pre><code class="java">// IMyAidlInterface.aidl
package cc.abto.demo;

// Declare any non-default types here with import statements

interface IMyAidlInterface &#123;
    /**
     * Demonstrates some basic types that you can use as parameters
     * and return values in AIDL.
     */
    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
            double aDouble, String aString);
&#125;
</code></pre>
<p>上面就是studio帮我生成的aidl文件。basicTypes这个方法可以无视，看注解知道这个方法只是告诉你在AIDL中你可以使用的基本类型（int, long, boolean, float, double, String），因为这里是要跨进程通讯的，所以不是随便你自己定义的一个类型就可以在AIDL使用的，这些后面会说。我们在AIDL文件中定义一个我们要提供给第二个APP使用的接口。</p>
<pre><code class="java">interface IMyAidlInterface &#123;
   String getName();
&#125;
</code></pre>
<p>定义好之后，就可以<strong>sync project</strong>一下，然后新建一个service。在service里面创建一个内部类，继承你刚才创建的AIDL的名称里的Stub类,并实现接口方法,在onBind返回内部类的实例。</p>
<pre><code class="java">public class MyService extends Service
&#123;

    public MyService()
    &#123;

    &#125;

    @Override
    public IBinder onBind(Intent intent)
    &#123;
        return new MyBinder();
    &#125;

    class MyBinder extends IMyAidlInterface.Stub
    &#123;

        @Override
        public String getName() throws RemoteException
        &#123;
            return &quot;test&quot;;
        &#125;
    &#125;
&#125;
</code></pre>
<p>接下来，将我们的AIDL文件拷贝到第二个项目，然后<strong>sync project</strong>一下工程。</p>
<img src="/2016/06/09/Android%E4%B8%ADAIDL%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/2.webp" class="">

<p>这边的包名要跟第一个项目的一样哦，这之后在Activity中绑定服务。</p>
<pre><code class="java">public class MainActivity extends AppCompatActivity
&#123;


    private IMyAidlInterface iMyAidlInterface;

    @Override
    protected void onCreate(Bundle savedInstanceState)
    &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        bindService(new Intent(&quot;cc.abto.server&quot;), new ServiceConnection()
        &#123;

            @Override
            public void onServiceConnected(ComponentName name, IBinder service)
            &#123;

                iMyAidlInterface = IMyAidlInterface.Stub.asInterface(service);
            &#125;

            @Override
            public void onServiceDisconnected(ComponentName name)
            &#123;

            &#125;
        &#125;, BIND_AUTO_CREATE);
    &#125;

    public void onClick(View view)
    &#123;
        try
        &#123;
            Toast.makeText(MainActivity.this, iMyAidlInterface.getName(), Toast.LENGTH_SHORT).show();
        &#125;
        catch (RemoteException e)
        &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>这边我们通过隐式意图来绑定service，在onServiceConnected方法中通过**IMyAidlInterface.Stub.asInterface(service)**获取iMyAidlInterface对象，然后在onClick中调用iMyAidlInterface.getName()。</p>
<img src="/2016/06/09/Android%E4%B8%ADAIDL%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/3.webp" class="">

<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>如果我要在AIDL中使用自定义的类型，要怎么做呢。首先我们的自定义类型要实现<strong>Parcelable</strong>接口，下面的代码中创建了一个User类并实现Parcelable接口。这边就不对Parcelable进行介绍了，不熟悉的童鞋自行查找资料，总之我们这边可以借助studio的Show Intention Action（也就是Eclipse中的Quick Fix，默认是alt+enter键）帮我们快速实现Parcelable接口。</p>
<img src="/2016/06/09/Android%E4%B8%ADAIDL%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/4.webp" class="">

<p>接下新建一个aidl文件，名称为我们自定义类型的名称，这边是User.aidl。在User.aidl申明我们的自定义类型和它的完整包名，注意这边parcelable是小写的，不是Parcelable接口，一个自定类型需要一个这样同名的AIDL文件。</p>
<pre><code class="java">package cc.abto.demo;
parcelable User;
</code></pre>
<p>然后再在我们的AIDL接口中导入我们的AIDL类型。</p>
<img src="/2016/06/09/Android%E4%B8%ADAIDL%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/5.webp" class="">
<p>然后定义接口方法，<strong>sync project</strong>后就可以在service中做具体实现了。</p>
<pre><code class="java">public class MyService extends Service
&#123;
    //...
    @Override
    public IBinder onBind(Intent intent)
    &#123;
        return new MyBinder();
    &#125;

    class MyBinder extends IMyAidlInterface.Stub
    &#123;
        //...
        @Override
        public User getUserName() throws RemoteException
        &#123;
            return new User(&quot;wswf&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>最后将我们的AIDL文件和自定义类型的java一并拷贝到第二个项目，注意包名都要一样哦</p>
<img src="/2016/06/09/Android%E4%B8%ADAIDL%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/6.webp" class="">
<p>然后就可以在Activity中使用该自定义类型的AIDL接口了</p>
<pre><code class="java">public class MainActivity extends AppCompatActivity
&#123;
    //...
    public void onClick(View view)
    &#123;
        try
        &#123;
            Toast.makeText(MainActivity.this, iMyAidlInterface.getUserName().getName(), Toast.LENGTH_SHORT).show();
        &#125;
        catch (RemoteException e)
        &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>效果图就不贴了哈，通过这种方式我们就可以让两个APP之间进行交互了。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>为什么APP间的进程交互这么麻烦，是因为它们属于不同的进程，之间的交互涉及到进程间的通讯。而AIDL只是Android中众多进程间通讯方式中的一种方式，那么AIDL到底是什么鬼，它是如何工作的，Android的IPC机制又是怎样的呢。我将在下一篇文章<a href="http://www.jianshu.com/writer#/notebooks/4326108/notes/4350318">Android中AIDL的工作原理</a>中介绍。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中AIDL的工作原理</title>
    <url>/2016/06/14/Android%E4%B8%ADAIDL%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>在上一篇文章中<a href="/2016/06/09/Android%E4%B8%ADAIDL%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3">Android中AIDL的使用详解</a>介绍了AIDL的使用流程，这篇文章我们说说AIDL的工作原理。</p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>在这之前我们先简单说一下IPC，IPC是<strong>Inter-Process Communication</strong>的缩写，是进程间通信或者跨进程通信的意思，既然说到进程，大家要区分一下进程和线程，<strong>进程一般指的是一个执行单元，它拥有独立的地址空间，也就是一个应用或者一个程序。线程是CPU调度的最小单元，是进程中的一个执行部分或者说是执行体，两者之间是包含与被包含的关系</strong>。因为进程间的资源不能共享的，所以每个系统都有自己的IPC机制，Android是基于Linux内核的移动操作系统，但它并没有继承Linux的IPC机制，而是有着自己的一套IPC机制。</p>
<span id="more"></span>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>Binder就是Android中最具特色的IPC方式，AIDL其实就是通过Binder实现的，因为在我们定义好aidl文件后，studio就帮我们生成了相关的Binder类。事实上我们在使用AIDL时候继承的Stub类，就是studio帮我们生成的Binder类，所以我们可以通过查看studio生成的代码来了解Binder的工作原理。首先我们定义一个AIDL文件</p>
<pre><code class="java">// UserManager.aidl
package cc.abto.demo;

interface UserManager &#123;

    String getName();

    String getOtherName();
&#125;
</code></pre>
<p><strong>sycn project</strong>工程后，查看生成的UserManager.java文件</p>
<pre><code class="java">package cc.abto.demo;
// Declare any non-default types here with import statements

public interface UserManager extends android.os.IInterface
&#123;

    /**
     * Local-side IPC implementation stub class.
     */
    public static abstract class Stub extends android.os.Binder implements cc.abto.demo.UserManager
    &#123;
       //...
    &#125;

    public java.lang.String getName() throws android.os.RemoteException;

    public java.lang.String getOtherName() throws android.os.RemoteException;
&#125;                
</code></pre>
<p>生成的代码还是比较多的，我就不一次性全部贴上来了，先按类结构来看。</p>
<img src="/2016/06/14/Android%E4%B8%ADAIDL%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/1.webp" class="">

<p>sutido帮我们生成了一个继承android.os.IInterface接口的UserManager接口，所有在Binder中传输的接口都必须实现IInterface接口。接口定义了我们在AIDL文件中定义的方法，然后还有个内部静态类Stub，我们接着看这个Stub。</p>
<pre><code class="java">public static abstract class Stub extends android.os.Binder implements cc.abto.demo.UserManager
    &#123;

        private static final java.lang.String DESCRIPTOR = &quot;cc.abto.demo.UserManager&quot;;

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub()
        &#123;
            this.attachInterface(this, DESCRIPTOR);
        &#125;

        /**
         * Cast an IBinder object into an cc.abto.demo.UserManager interface,
         * generating a proxy if needed.
         */
        public static cc.abto.demo.UserManager asInterface(android.os.IBinder obj)
        &#123;

            if ((obj == null))
            &#123;
                return null;
            &#125;
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) &amp;&amp; (iin instanceof cc.abto.demo.UserManager)))
            &#123;
                return ((cc.abto.demo.UserManager) iin);
            &#125;
            return new cc.abto.demo.UserManager.Stub.Proxy(obj);
        &#125;

        @Override
        public android.os.IBinder asBinder()
        &#123;
            return this;
        &#125;

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
        &#123;

            switch (code)
            &#123;
                case INTERFACE_TRANSACTION:
                &#123;
                    reply.writeString(DESCRIPTOR);
                    return true;
                &#125;
                case TRANSACTION_getName:
                &#123;
                    data.enforceInterface(DESCRIPTOR);
                    java.lang.String _result = this.getName();
                    reply.writeNoException();
                    reply.writeString(_result);
                    return true;
                &#125;
                case TRANSACTION_getOtherName:
                &#123;
                    data.enforceInterface(DESCRIPTOR);
                    java.lang.String _result = this.getOtherName();
                    reply.writeNoException();
                    reply.writeString(_result);
                    return true;
                &#125;
            &#125;
            return super.onTransact(code, data, reply, flags);
        &#125;

        private static class Proxy implements cc.abto.demo.UserManager
        &#123;
           //...
        &#125;

        static final int TRANSACTION_getName = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);

        static final int TRANSACTION_getOtherName = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
    &#125;
</code></pre>
<p>Stub继承了android.os.Binder并实现UserManager接口，下图是Stub的类结构。</p>
<img src="/2016/06/14/Android%E4%B8%ADAIDL%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2.webp" class="">
<p>我们可以看到Stub中的常量，其中两个int常量是用来标识我们在接口中定义的方法的，DESCRIPTOR常量是 Binder的唯一标识。<br><strong>asInterface</strong> 方法用于将服务端的Binder对象转换为客户端所需要的接口对象，该过程区分进程，如果进程一样，就返回服务端Stub对象本身，否则呢就返回封装后的Stub.Proxy对象。<br><strong>onTransact</strong> 方法是运行在服务端的Binder线程中的，当客户端发起远程请求后，在底层封装后会交由此方法来处理。通过code来区分客户端请求的方法，注意一点的是，如果该方法返回false的换，客户端的请求就会失败。一般可以用来做权限控制。<br>最后我们来看一下Proxy代理类。</p>
<pre><code class="java">private static class Proxy implements cc.abto.demo.UserManager
&#123;

    private android.os.IBinder mRemote;

    Proxy(android.os.IBinder remote)
    &#123;

        mRemote = remote;
    &#125;

    @Override
    public android.os.IBinder asBinder()
    &#123;

        return mRemote;
    &#125;

    public java.lang.String getInterfaceDescriptor()
    &#123;

        return DESCRIPTOR;
    &#125;

    @Override
    public java.lang.String getName() throws android.os.RemoteException
    &#123;

        android.os.Parcel _data = android.os.Parcel.obtain();
        android.os.Parcel _reply = android.os.Parcel.obtain();
        java.lang.String _result;
        try
        &#123;
            _data.writeInterfaceToken(DESCRIPTOR);
            mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0);
            _reply.readException();
            _result = _reply.readString();
        &#125;
        finally
        &#123;
            _reply.recycle();
            _data.recycle();
        &#125;
        return _result;
    &#125;

    @Override
    public java.lang.String getOtherName() throws android.os.RemoteException
    &#123;

        android.os.Parcel _data = android.os.Parcel.obtain();
        android.os.Parcel _reply = android.os.Parcel.obtain();
        java.lang.String _result;
        try
        &#123;
            _data.writeInterfaceToken(DESCRIPTOR);
            mRemote.transact(Stub.TRANSACTION_getOtherName, _data, _reply, 0);
            _reply.readException();
            _result = _reply.readString();
        &#125;
        finally
        &#123;
            _reply.recycle();
            _data.recycle();
        &#125;
        return _result;
    &#125;
&#125;
</code></pre>
<p>代理类中我们主要看一下getName和getOtherName方法就可以了，这两个方法都是运行在客户端，当客户端发起远程请求时，_data会写入参数，当然这边的例子并没有（啦啦啦…），然后调用transact方法发起RPC(远程过程调用)请求，同时挂起当前线程，然后服务端的onTransact方法就会被 调起，直到RPC过程返回后，当前线程继续执行，并从_reply取出返回值（如果有的话），并返回结果。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>分析完sutido生成的Binder之后，我们就大概知道AIDL的工作原理，定义好AIDL文件只是方便sutido帮我生成所需的Binder类，AIDL并不是必须的文件，因为这个Binder类我们也可以手写出来（当然，你闲的没事的话），所以这边最重要的还是Binder的知识点，其他一些IPC方式其实都是通过Binder来实现的，比如说Messager，Bundle，ContentProvider，只是它们的封装方式不一样而已。总的来说，从应用层来说，Binder是客户端和服务端之间通信的媒介。从FrameWork层来说，Binder是ServiceManager连接各种Manager和ManagerService的桥梁。Android系统中充斥着大量的CS模型，而Binder作为独有的IPC方式，如果我们能更好的理解它，对我们的开发工作就会带来更多的帮助。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中webview与js交互（二）</title>
    <url>/2016/05/18/Android%E4%B8%ADwebview%E4%B8%8Ejs%E4%BA%A4%E4%BA%92%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>在<a href="/2016/05/17/Android%E4%B8%ADwebview%E4%B8%8Ejs%E7%9A%84%E4%BA%A4%E4%BA%92%EF%BC%88%E4%B8%80%EF%BC%89">Android中webview与js的交互（一）</a>中简单介绍了webview与js交互的基本使用方法，接下来，为了方便后期的维护扩展，在这里分享一下我自己的一些经验。</p>
<span id="more"></span>
<h2 id="JS接口对象"><a href="#JS接口对象" class="headerlink" title="JS接口对象"></a>JS接口对象</h2><p>依据依赖倒转原则，这里我们定义一个js接口类，来统一管理webview与js之间交互的接口，例子如下：</p>
<pre><code class="java">public interface JavaScript&#123;

@JavascriptInterface    
public String getManufacturer(); 

@JavascriptInterface    
public String getVersionName();    
//...
&#125;
</code></pre>
<p>然后再创建一个抽象基类，实现一些基础共用方法：</p>
<pre><code class="java">public abstract  class BaseJavaScript 
&#123;

    private WebView webView;

    @Override
    public  final JavaScript setWebView(WebView webView, String name)
    &#123;
        this.webView = webView;
        webView.addJavascriptInterface(this,name);
        return this;
    &#125;

    @Override
    public final  void callFunction(String fn, String... arguments)//封装了webview调用js的方法
    &#123;
        if (webView == null)
        &#123;
            return;
        &#125;
        String functionStr = getFunctionStr(fn, arguments);
        webView.loadUrl(functionStr);

    &#125;

    private String getFunctionStr(String fn, String... arguments)
    &#123;
        StringBuilder stringBuilder = new StringBuilder(&quot;javascript:&quot;+fn+&quot;(&quot;);
        for (String argument : arguments)
        &#123;
            stringBuilder.append(argument+&quot;,&quot;);
        &#125;
        String s = stringBuilder.toString();
        String substring = s.substring(0, s.lastIndexOf(&quot;,&quot;));
        return substring+&quot;)&quot;;
    &#125;
&#125;
</code></pre>
<p>通过定义接口和进一步封装也方便你写一些单元测试来着，接下来就可以根据业务创建一些子类实现了</p>
<pre><code class="java">public class MainJavaScript extends BaseJavaScript implements JavaScript
&#123;


    @Override
    public String getManufacturer()
    &#123;
       //TODO
        return null;
    &#125;

    @Override
    public String getVersionName()
    &#123;
        //TODO
        return null;
    &#125;
&#125;
</code></pre>
<h2 id="在MVP中的实践"><a href="#在MVP中的实践" class="headerlink" title="在MVP中的实践"></a>在MVP中的实践</h2><p>我自己的项目中是只实现一个子类来统一管理所有的js接口，因为做的是混合应用，原生端主要提供一些本地服务给h5页面调用，这些服务接口都是一样的。最开始还没做MVP的时候是每个页面都给一个JS实现子类，改起来真的是很蛋疼，下面是现在项目中公共presenter中的一些类和接口，这边我是把Activity作为presentter的。</p>
<img src="/2016/05/18/Android%E4%B8%ADwebview%E4%B8%8Ejs%E4%BA%A4%E4%BA%92%EF%BC%88%E4%BA%8C%EF%BC%89/1.webp" class="">
<p>这边的BaseJS和上面的MainJavaScript是一样的</p>
<pre><code class="java">public class BaseJS extends JavascriptInteraction
&#123;

    private final IActivity activity;

    public BaseJS(IActivity activity)
    &#123;
        this.activity = activity;
    &#125;

    @JavascriptInterface
    public String getManufacturer()
    &#123;
        return Build.MANUFACTURER.toLowerCase().replaceAll(&quot;&quot;, &quot;&quot;);
    &#125;
    @JavascriptInterface
    public void scanQR()
    &#123;
        activity.scanQR();
    &#125;

&#125;
</code></pre>
<p>IActivity接口中定义的方法大部分跟BaseJS是一样的，但这些方法是无法或者不好在BaseJS中实现的，这样就可以把实现延迟到具体的Acitivity中，而且又能统一管理这些js接口。</p>
<pre><code class="java">public interface IActivity
&#123;

    void loginOK(String userInfo);

    void showWelcome(boolean isShow);
//...
&#125;
</code></pre>
<p>然后在BaseJSActivity中对方法进行具体的实现了。</p>
<pre><code class="java">public abstract class BaseJSActivity extends BaseActivity implements IActivity
&#123;

    protected static final String TAG = &quot;BaseJSActivity&quot;;

    protected BaseJS js;

    protected User user;
    
     @Override
    public void loginOK(String userInfo)
    &#123;
        User.isLogin = true;
        user = UserModel.getInstance(this).writeUser2SP(userInfo);
        checkLoginBeforeLoad(url);
    &#125;
&#125;
</code></pre>
<p>其他的Activity只要继承该基类就可以了，不同的业务逻辑只要重写部分代码就行了。如果后期js接口部分需要改动，维护扩展起来就挺方便的了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要是介绍一下自己管理webview与js的交互接口的一些经验，因为自己水平有限，仅供交流参考，如果文中有不妥和错误，欢迎指正。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中webview与js的交互（一）</title>
    <url>/2016/05/17/Android%E4%B8%ADwebview%E4%B8%8Ejs%E7%9A%84%E4%BA%A4%E4%BA%92%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="webview中调用js"><a href="#webview中调用js" class="headerlink" title="webview中调用js"></a>webview中调用js</h2><pre><code class="java">webView.getSettings().setJavaScriptEnabled(true);//设置js脚本可用
webView.loadUrl(&quot;url&quot;);//加载页面
webView.loadUrl(&quot;javascript:test(a,b,c)&quot;);//调用js方法
</code></pre>
<span id="more"></span>
<h2 id="html中调用java"><a href="#html中调用java" class="headerlink" title="html中调用java"></a>html中调用java</h2><h3 id="android中配置"><a href="#android中配置" class="headerlink" title="android中配置"></a>android中配置</h3><pre><code class="java">webView.addJavascriptInterface(new MyJSInterface(),&quot;app&quot;);//添加js脚本接口

class  MyJSInterface
&#123;   
 
@JavascriptInterface
public void androidMethod() //提供给js调用的方法
  &#123;
  //todo    
  &#125;
&#125;
</code></pre>
<h3 id="html中使用"><a href="#html中使用" class="headerlink" title="html中使用"></a>html中使用</h3><pre><code class="HTML">&lt;div id=&#39;b&#39;&gt;
&lt;a onclick=&quot;window.app.androidMethod()&quot;&gt;b.c&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  webview与js的交互的基本使用方法如上，补充几点：</p>
<ul>
<li><p>在这篇<a href="http://jiajixin.cn/2014/09/16/webview-js-safety/">博客</a>中抄出这段话<br>Android Webview有两个非常知名的漏洞:<br>1、最近爆出来的UXSS漏洞，可以越过同源策略，获得任意网页的Cookie等信息，Android 4.4以下都有此问题，基本无解，只能重新编译浏览器内核解决，详情可以参考<a href="http://zhuanlan.zhihu.com/fooying/19840752">最近移动安全三两事</a>，感兴趣的可以去看一下<a href="http://weibo.com/rayh4c">@RAyH4c</a>劫持微博、QQ空间的视频。<br>2、成名已久的任意命令执行漏洞，通过addJavascriptInterface方法，Js可以调用Java对象方法，通过反射机制，Js可以直接获取Runtime，从而执行任意命令。Android 4.2以上，可以通过声明**@JavascriptInterface**保证安全性，4.2以下不能再调用addJavascriptInterface，需要另谋他法。</p>
</li>
<li><p>在实际的混合应用开发中需要对js交互做一些封装设计以便于后期的维护扩展，我会在<a href="http://www.jianshu.com/p/cafd518e3aae">Android中webview与js的交互（二）</a>中分享一下我的经验</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中全局异常的捕获</title>
    <url>/2016/06/03/Android%E4%B8%AD%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<p>应用的crash是让人很蛋疼的问题，在开发测试的时候还能根据日志输出什么的进行排查修复，但是应用发布以后，用户的随意性访问出现测试时未知的Bug导致我们的程序crash，此时我们是无法直接获取的错误log的，也就无法修复Bug。所以这时候我们就需要一个能全局捕获异常，并且将这个异常信息上传到服务器的功能，以便根据收集到的异常信息，在后期的版本中进行修复，改善用户体验。</p>
<span id="more"></span>

<h2 id="UncaughtExceptionHandler"><a href="#UncaughtExceptionHandler" class="headerlink" title="UncaughtExceptionHandler"></a>UncaughtExceptionHandler</h2><p>实现这个功能我们只要自定义一个实现了Thread.UncaughtExceptionHandler接口的异常处理类，并在应用初始化的时候注册这个类就可以了。</p>
<pre><code class="java">public class CrashHandler implements Thread.UncaughtExceptionHandler
&#123;

    private static CrashHandler ourInstance = new CrashHandler();

    public static CrashHandler getInstance()
    &#123;
        return ourInstance;
    &#125;

    private CrashHandler()
    &#123;
    &#125;

    @Override
    public void uncaughtException(Thread thread, Throwable ex)
    &#123;
     //TODO
    &#125;
&#125;
</code></pre>
<p>这边呢，我们一般将CrashHandler写成单例模式，重写上面的uncaughtException方法自定义对异常的处理，然后呢，Application或者Activity的onCreate方法里注册这个异常处理类就可以了</p>
<pre><code class="java">Thread.setDefaultUncaughtExceptionHandler(CrashHandler.getInstance());
</code></pre>
<p>这边呢再贴一点uncaughtException中处理异常的代码，给大家参考一下</p>
<pre><code class="java">public void uncaughtException(Thread thread, Throwable ex)
&#123;

    
    dumpEx2SdCard(ex);//将错误日志导入到SD卡中
    upEx2server();//将日志上传到服务器
    if (mDefaultHandler != null)
    &#123;
        mDefaultHandler.uncaughtException(thread, ex);
    &#125;
    else
    &#123;
        Process.killProcess(Process.myPid());//做一些退出或者提醒处理
    &#125;
&#125;

private void dumpEx2SdCard(Throwable ex)
&#123;
         //...
        PrintWriter printWriter = new PrintWriter(new BufferedWriter(new FileWriter(file)));
        PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES);
        ex.printStackTrace(printWriter);
        printWriter.print(ex.getCause());
        printWriter.print(time);
        printWriter.print(ex.getMessage());
        printWriter.print(&quot;APP版本：&quot;+ packageInfo.versionName+&quot;_&quot;+packageInfo.versionCode);
        printWriter.print(&quot;android 版本：&quot;+ Build.VERSION.RELEASE+&quot;_&quot;+Build.VERSION.SDK_INT);
        printWriter.print(&quot;制造商：&quot;+Build.MANUFACTURER);
        //...
&#125;
</code></pre>
<p>一般这边的代码都是将错误日志和设备信息写到SD卡中然后再上传到服务器中，具体实现就不贴那么多的代码啦，注重流程就是啦。<br>##开发者服务<br>集成一些第三方服务可以大大的加快我们的开发速度，诸如此类的统计功能我们只要集成一些像百度云推送，极光推送，友盟+等等的第三方SDK，然后做一些初始化，几行代码就搞定了。而且这些平台提供的各种强大方便的服务，确实是我们开发者的福音。像下图展示的友盟应用管理中心，各种统计功能基本上都能满足我们的需求了。</p>
<img src="/2016/06/03/Android%E4%B8%AD%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7/1.webp" class="">

<p>再推荐一个网站。<a href="http://www.devstore.cn/">DevStore <a href="http://www.baidu.com/link?url=upIpM9HcrAOsbxadr2T4f4BMfV6mi2FG54BHlfkzdTmq3BtE6gLYr5PB0rCTTQJ_&wd=&eqid=b3a05c1a00012bae00000005575122a2">移动互联网企业运营解决方案整合平台</a></a>这里面总结了各种强大的第三方服务平台，建议收藏哦。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中反射的简单应用</title>
    <url>/2016/05/31/Android%E4%B8%AD%E5%8F%8D%E5%B0%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>自己对反射的理解和应用还处于比较浅显的阶段，写这篇文章更多在于整理总结，也就是帮助自己进一步的理解和学习反射机制。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射的概念是由Smith在1982年首次提出的，主要是指<strong>程序可以访问、检测和修改它本身状态或行为的一种能力</strong>。</p>
<h2 id="java中类反射"><a href="#java中类反射" class="headerlink" title="java中类反射"></a>java中类反射</h2><p>反射是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对<strong>自身进行检查，或者说“自审”，并能直接操作程序的内部属性和方法</strong>。<br>简单总结这些定义，那就是反射可以让我们获得一个类的所有信息，包括私有属性和私有方法，对于我们这种小白，先知道这点就可以啦，那在java中如何使用发射呢。这里我们随便创建一个类来演示。比如说创建一个Book类：</p>
<pre><code class="java">public class Book implements Parcelable
&#123;
    private int id=1;
    private String name=&quot;android&quot;;

    private String author=&quot;wf&quot;;

    private String getName()
    &#123;
        return name;
    &#125;
&#125;
</code></pre>
<span id="more"></span>
<p>Book类中属性和方法都是私有的，现在我们通过反射来访问这些属性和方法。</p>
<pre><code class="java">String s = null;
try
&#123;
    Class&lt;?&gt; bookClass = Class.forName(&quot;cc.abto.demo.Book&quot;);//完整类名
    Object book = bookClass.newInstance();//获得实例
    Method getAuthor = bookClass.getDeclaredMethod(&quot;getName&quot;);//获得私有方法
    getAuthor.setAccessible(true);//调用方法前，设置访问标志
    s = (String) getAuthor.invoke(book);//使用方法
&#125;
catch (Exception e)
&#123;
    e.printStackTrace();
&#125;
</code></pre>
<p>可以看到上面代码中我们用Class和Method这两个类完成了反射，这两个类分别对应了类和方法，也就是包装了类和方法的信息，下面对反射的部分API做一下简单介绍：</p>
<ul>
<li> Class类：代表一个类，位于java.lang包下</li>
<li> Field类：代表类的成员变量（成员变量也称为类的属性）</li>
<li> Method类：代表类的方法</li>
<li> Constructor类：代表类的构造方法</li>
<li> Array类：提供了动态创建数组，以及访问数组的元素的静态方法</li>
</ul>
<p>在Java中，每个class都有一个相应的Class对象。也就是说，当我们编写一个类，编译完成后，在生成的.class文件中，就会产生一个Class对象，用于表示这个类的类型信息。 java中的Class三种获取方式：</p>
<pre><code class="java">//使用Class类的静态方法forName()，用类的名字获取一个Class实例
Class&lt;?&gt; bookClass = Class.forName(&quot;cc.abto.demo.Book&quot;);

//利用对象调用getClass()方法获取该对象的Class实例
Book book = new Book();
Class&lt;? extends Book&gt; bookClass = book.getClass();

//运用.class的方式来获取Class实例，对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的基本数据类型的Class实例
Class&lt;Book&gt; bookClass = Book.class;
Class&lt;Integer&gt; type = Integer.TYPE;
</code></pre>
<p>然后再贴一些常用的方法</p>
<pre><code class="java">    public Annotation[] getAnnotations () //获取这个类中所有注解

    getClassLoader() //获取加载这个类的类加载器

    getDeclaredMethods() //获取这个类中的所有方法

    getReturnType() //获取方法的返回类型

    getParameterTypes() //获取方法的传入参数类型

    isAnnotation() //测试这类是否是一个注解类

    getDeclaredConstructors() //获取所有的构造方法

    getDeclaredMethod(String name, Class… parameterTypes)// 获取指定的构造方法（参数：参数类型.class）

    getSuperclass() //获取这个类的父类

    getInterfaces()// 获取这个类实现的所有接口

    getFields() //获取这个类中所有被public修饰的成员变量

    getField(String name) //获取指定名字的被public修饰的成员变量

    newInstance() //返回此Class所表示的类，通过调用默认的（即无参数）构造函数创建的一个新实例
</code></pre>
<p>更多的方法和方法的注解大家可以查看文档。</p>
<h2 id="Android中的简单应用"><a href="#Android中的简单应用" class="headerlink" title="Android中的简单应用"></a>Android中的简单应用</h2><p>查看Android SDK的源码时候。你会发现很多类或方法中经常加上了“@hide”注释标记，这些API是不允许在程序中调用的。Hidden API之所以被隐藏，是想阻止开发者使用SDK中那些未完成或不稳定的部分（接口或架构）。如图所示</p>
<img src="/2016/05/31/Android%E4%B8%AD%E5%8F%8D%E5%B0%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/1.webp" class="">
<p>所以在开发中，我们不仅可以通过反射获取私有属性和方法，也可以利用反射获取一些SDK对外部隐藏的API，比如说前阵子在做蓝牙开发的时候，自动配对的一些方法在API 19以后才对外开放的，这边我们就可以使用反射来实现配对功能了</p>
<pre><code class="java">try
&#123;
    Class&lt;BluetoothDevice&gt; bluetoothDeviceClass = BluetoothDevice.class;
    bluetoothDeviceClass.getMethod(&quot;setPin&quot;, byte[].class).invoke(device, &quot;1234&quot;.getBytes());
    bluetoothDeviceClass.getMethod(&quot;createBond&quot;).invoke(device);
    bluetoothDeviceClass.getMethod(&quot;setPairingConfirmation&quot;, boolean.class).invoke(device, true);
    bluetoothDeviceClass.getMethod(&quot;cancelPairingUserInput&quot;).invoke(device);

&#125;
catch (Exception e)
&#123;
    e.printStackTrace();
&#125;
</code></pre>
<h2 id="反射的好处"><a href="#反射的好处" class="headerlink" title="反射的好处"></a>反射的好处</h2><p>反射不仅可以让我们获得隐藏的方法和属性，还可以让<strong>对象的实例化从编译时转化为运行时</strong>，因为我们可以通过Class.forName(“cc.abto.demo.Book”).newInstance()的方法来生成新的实例，而这边的”cc.abto.demo.Book”是一个字符串，完全可以用变量来代替，再结合抽象工厂模式什么的，我们就可以很大程度上对程序应用中的功能模块进行解耦合。可能这边简单几句没能解释清楚，大家可以看看《大话设计模式》之类的书，里面就介绍的比较清楚明白了。<br>##反射的弊端<br>反射带来的两大弊端可能就是安全和性能问题了吧，这方面我知之甚少，有待进一步的了解和学习。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>因为自己水平有限，如果有些错误的地方还请大家见谅。下面贴出几篇写得比较好和详细的博客。</p>
<ul>
<li><a href="http://blog.qiji.tech/archives/4374">【Android】 认识反射机制（Reflection）</a></li>
<li><a href="http://www.cnblogs.com/crazypebble/archive/2011/04/13/2014582.html">Java反射机制的原理及在Android下的简单应用</a></li>
<li><a href="http://zlb1986.iteye.com/blog/937781">java中的反射机制</a></li>
<li><a href="http://efany.github.io/2016/04/02/Android%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">Android注解与反射机制</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的图片裁剪（一）之系统裁剪工具</title>
    <url>/2016/05/18/Android%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E7%B3%BB%E7%BB%9F%E8%A3%81%E5%89%AA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>应用中图片裁剪的需求是很常见的，在android中裁剪的图片最简单的方法就是调用系统中的裁剪图片应用</p>
<pre><code class="java">Intent intent = new Intent();
intent.setAction(&quot;com.android.camera.action.CROP&quot;);
intent.setDataAndType(uri, &quot;image/*&quot;);
startActivityForResult(intent, Constants.REQUEST_CODE_RESIZE_IMAGE);
</code></pre>
<p>当然在调用系统的裁剪功能时，我们还可以附加一些其他的信息：</p>
<pre><code class="java">intent.putExtra(&quot;outputX&quot;, 300);  //裁剪图片的宽
intent.putExtra(&quot;outputY&quot;, 300);  
intent.putExtra(&quot;aspectX&quot;, 1);  //裁剪方框宽的比例
intent.putExtra(&quot;aspectY&quot;, 1);  
intent.putExtra(&quot;scale&quot;, true);  //是否保持比例
intent.putExtra(&quot;return-data&quot;, false);  //是否返回bitmap

intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);  //保存图片到指定uri
intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString());  //输出格式
</code></pre>
<p>上面的是一些常用的附加信息，如果你的outputX和outputY设置的比较大的话，返回的图片可能会导致OOM。最后在onActivityResult中接收图片就可以了</p>
<pre><code class="java">protected void onActivityResult(int requestCode, int resultCode, Intent data)
&#123;
    super.onActivityResult(requestCode, resultCode, data);
    switch (requestCode)
    &#123;
        case CROP_IMAGE_SYS:
            Bitmap bitmap = (Bitmap) data.getParcelableExtra(&quot;data&quot;);//拿到返回图片
            /*try
            &#123;
             //取的裁剪后保存到本地的图片
              bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(uri));
            &#125;
            catch (FileNotFoundException e)
            &#123;
              e.printStackTrace();
            &#125;*/
            //TODO
            break;
//...
</code></pre>
<p>当然因为android碎片化严重，不同厂商的系统也有所差异，所以系统的裁剪图片功能也可能有所不同，这也是坑，就像在我的项目中，发现有些手机基于内存考虑对图片缩略了很多，这样裁剪出来的图片分辨率就达不到项目要求，这时候就只能求助于第三方的开源项目或者自定义了，在第二篇文章中<a href="http://www.jianshu.com/p/941bfe005e02">Android中的图片裁剪（二）</a>，我会说说如何自己实现裁剪图片的功能。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的图片裁剪（三）之自定义裁剪工具</title>
    <url>/2016/05/24/Android%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A3%81%E5%89%AA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>在上一篇文章中<a href="/2016/05/19/Android%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE">Android中的图片裁剪（二）之开源项目</a>介绍了一些优秀的图片裁剪开源项目，在我们实现自己的裁剪功能的时候，也可以看下这些开源项目的源码，看看大牛们都是怎么实现的。</p>
<span id="more"></span>

<h2 id="createBitmap方法"><a href="#createBitmap方法" class="headerlink" title="createBitmap方法"></a>createBitmap方法</h2><p>首先要做图片裁剪的功能，要先认识Bitmap，在这个类里面，有几个方法可以帮助我们实现功能。就比如下面这一个方法</p>
<pre><code class="java">/**
 * Returns an immutable bitmap from the specified subset of the source
 * bitmap. The new bitmap may be the same object as source, or a copy may
 * have been made. It is initialized with the same density as the original
 * bitmap.
 *...
 */
public static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height)
</code></pre>
<p>好吧，方法注解太长，被我省略掉一些了，但是用起来其实挺简单的，只要传入指定的范围，它就能生成一个新的位图给你。（这里先说一句，图片的裁剪功能其实做起来不难，要做好就挺麻烦的，在实际的工具开发中免不了要自定义View这样的工作），而这边的范围一般是一个可拖动的方框，点击裁剪按钮的时候生成我们需要的图片。当然createBitmap方法还有很多其他重载实现，这里就不一一贴出来了。在具体实现的时候我们可以自定义两个View</p>
<pre><code class="java">public class CropImageView extends ImageView &#123;

    HighlightView hv;
    //...
 
&#125;

class HighlightView &#123;
    //...
&#125;
</code></pre>
<p>这里只是简单的提供一下思路，HighlightView用来表示裁剪框对象，封装裁剪框的一些信息啊，比如宽高和触摸状态什么的。CropImageView继承ImageView用来显示图片和处理触摸事件，在触摸事件中改变HighlightView的状态：</p>
<pre><code class="java">public boolean onTouchEvent(@NonNull MotionEvent event) &#123;
    switch (event.getAction()) &#123;
    case MotionEvent.ACTION_DOWN:
            //对触摸点进行一些逻辑判断，比如摸到裁剪框的边还是其他什么的
            int edge = hv.getHit(event.getX(), event.getY());
            //...
            //然后根据逻辑判断结果设置裁剪框的状态
            hv.setMode((edge == HighlightView.MOVE)
                        ? HighlightView.ModifyMode.Move
                        : HighlightView.ModifyMode.Grow);
            //...
        break;
            //...
</code></pre>
<p>啦啦啦，是不是说了跟没说一样，主要是具体实现起来真的挺麻烦的，贴那么多代码出来也没啥用，我自己都要看晕了，总归自己造轮子还是挺辛苦的，而且刚造出来也肯定有一些问题的，所以才有那句名言么，不要重复造轮子，我觉得只要看懂源代码的思路，然后根据需求，在别人的轮子上进行改造，这样就快的多啦。</p>
<h2 id="Matrix的基本使用"><a href="#Matrix的基本使用" class="headerlink" title="Matrix的基本使用"></a>Matrix的基本使用</h2><p>一般呢，在裁剪的工具中，在对图片裁剪前，多可以对图片进行一些缩放，平移，旋转之类的操作，这些效果都是可以通过Matrix来实现的，那这个类怎么用呢。我们先看一下<a href="file:///D:/Android/sdk/docs/reference/android/graphics/Matrix.html">官方文档中Matrix</a>的介绍（自带梯子） ，首先看一下它的官方定义：</p>
<p>**The Matrix class holds a 3x3 matrix for transforming coordinates. **</p>
<p>直译过来呢，就是<strong>一个转换坐标的3x3矩阵</strong>，你妹啊，什么是3x3矩阵…我也不知道啊 ，高等数学这东西我早就扔了好么，不过不知道没关系，面向对象么，我先知道怎么用就可以了，有时间有闲情再去深究。我们先主要看一下Matrix类里面，我们要用到的一些方法(补充说一下，这Matrix类是在graphics包下的，不要导成opengl包下的)：</p>
<pre><code class="java">/**
 * Postconcats the matrix with the specified translation.
 * M&#39; = T(dx, dy) * M
 */
public boolean postTranslate(float dx, float dy)

/**
 * Postconcats the matrix with the specified rotation.
 * M&#39; = R(degrees) * M
 */
public boolean postRotate(float degrees)
</code></pre>
<p>好啦，毕竟是文档找的到东西，我这里就只贴两个方法出来，看注解应该很容易理解方法的使用，<strong>第一个方法就是对矩阵进行左乘T(dx, dy)，第二个方法就是对矩阵左乘R(degrees)<strong>，通过源码我们可以看到，方法里面通过jni调用lib层用c，c++实现运算转换的。反正直白点讲，在对它进行图片变换的时候，</strong>第一个方法就是平移图片，第二个方法就是旋转图片</strong>，啦啦啦，其他方法大家可以自行查找文档，问题都不大。</p>
<h2 id="图片的平移，缩放，旋转"><a href="#图片的平移，缩放，旋转" class="headerlink" title="图片的平移，缩放，旋转"></a>图片的平移，缩放，旋转</h2><p>通过重写View或者Activity的onTouch事件来进行图片的平移，缩放和旋转会比较方便，这里我们要先做一些初始化工作，比如获取图片之类的，一般我们将图片的大小控制在手机内存的1/8，防止OOM和卡顿，然后就是在onTouch事件里做具体实现：</p>
<pre><code class="java">public boolean onTouch(View v, MotionEvent event)
&#123;

    switch (event.getAction() &amp; MotionEvent.ACTION_MASK)
    &#123;
        // 主点按下
        case MotionEvent.ACTION_DOWN:
            cachMatrix.set(matrix);//用来变化的矩阵
            prev.set(event.getX(), event.getY());
            mode = DRAG;
            break;
        //...
        case MotionEvent.ACTION_MOVE:
            if (mode == DRAG)//拖动
            &#123;
                matrix.set(cachMatrix);
                matrix.postTranslate(event.getX() - prev.x, event.getY() - prev.y);
            &#125;
            else if (mode == ZOOM)//缩放
            &#123;
                float newDist = spacing(event);
                if (newDist &gt; 10f)
                &#123;
                    matrix.set(cachMatrix);
                    float tScale = newDist / dist;
                    matrix.postScale(tScale, tScale, mid.x, mid.y);
                &#125;
            &#125;
            break;
    &#125;
    imgView.setImageMatrix(matrix);
    //...
    return true;
&#125;
</code></pre>
<p>代码就放了部分上去，主要说明一下思路，当然在将这些功能和裁剪进行合并的时候，是要对裁剪框的位置再进行计算的,比如因为对图片缩放了，所以再返回剪裁框大小的时候是要乘上缩放值的。</p>
<pre><code class="java">public Rect getScaledCropRect(float scale) &#123;
    return new Rect((int) (cropRect.left * scale), (int) (cropRect.top * scale),
            (int) (cropRect.right * scale), (int) (cropRect.bottom * scale));
&#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>图片的裁剪就先写到这里，主要介绍了一些关键方法和整体的实现思路，后面有时间的话，我会把代码整理后发布到github上去的，到时候再来补链接。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的图片裁剪（二）之开源项目</title>
    <url>/2016/05/19/Android%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>在上一篇博客<a href="/2016/05/18/Android%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E7%B3%BB%E7%BB%9F%E8%A3%81%E5%89%AA%E5%B7%A5%E5%85%B7">Android中的图片裁剪（一）</a>中，简单介绍了一下使用系统自带的裁剪软件实现图片裁剪功能。可是有时候系统自带的裁剪软件不能满足项目需求的时候,只能用三方的或者自己写一个了。</p>
<span id="more"></span>

<h2 id="第三方开源项目"><a href="#第三方开源项目" class="headerlink" title="第三方开源项目"></a>第三方开源项目</h2><p>都说不要重复造轮子么，github上有很多优秀的开源项目：</p>
<ul>
<li><p><a href="https://github.com/jdamcd/android-crop">android-crop</a><br>在github搜crop这个项目是star最多的，我之前做的一个应用就是集成的这个开源项目，感觉还是不错的哈，直接拿来用还是挺方便的，在上面做二次开发也是挺快的。下面是效果图：</p>
<img src="/2016/05/19/Android%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/1.webp" class=""></li>
<li><p><a href="https://github.com/edmodo/cropper">Cropper</a><br>这个不仅能裁剪还能旋转哦，这个我也用过感觉也挺好的，集成也挺快的，能快速定制包括裁剪框在内的几个基础属性。下面是效果图：</p>
<img src="/2016/05/19/Android%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/2.webp" class=""></li>
<li><p><a href="https://github.com/beartung/tclip-android">itmap Smart Clipping using OpenCV</a><br>能自动识别图片中的重要区域，并且在图片裁剪时保留重要区域，比如说人脸识别啥的，还能自动识别其它重要区域。如果图片中未识别出人脸，则会根据特征分布计算出重区域 。下面是效果图：</p>
</li>
</ul>
<img src="/2016/05/19/Android%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/3.webp" class="">

<ul>
<li>其他还有很多像<a href="https://github.com/biokys/cropimage">cropimage</a>，<a href="https://github.com/IsseiAoki/SimpleCropView">SimpleCropView</a>，大家可以上github上自行查找。</li>
</ul>
<br>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>大部分情况下集成这些优秀的开源项目就可完成需求了。但在需要高度定制裁剪功能的时候，要怎么实现呢，下一篇文章中，就和大家探讨一下裁剪图片实现的原理。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中退出应用的实现</title>
    <url>/2016/05/30/Android%E4%B8%AD%E9%80%80%E5%87%BA%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>退出应用是项目开发中很基本的一个需求，这个功能很简单，也有很多实现的方式，这里把自己知道的退出方法做一个整理，跟大家交流分享一下。</p>
<span id="more"></span>
<h2 id="容器式"><a href="#容器式" class="headerlink" title="容器式"></a>容器式</h2><p>就是用一个全局容器把所有的Activity存起来，退出时遍历调用容器里Activity的finish方法就可以啦，这个效果很好，也很好操作的。创建一个单例来管理Acitivity，一般是在Application中实现的。</p>
<pre><code class="java">public class MyApplication extends Application
&#123;

    private List&lt;Activity&gt; activityList = new LinkedList&lt;Activity&gt;();//LinkedList便于删除和增加

    // 省略了单例代码...

    public void removeActivity(Activity activity)
    &#123;
        activityList.remove(activity);
    &#125;

    public void addActivity(Activity activity)
    &#123;

        activityList.add(activity);
    &#125;

    public void exit()
    &#123;

        for (Activity activity : activityList)
        &#123;
            activity.finish();
        &#125;
        System.exit(0);
    &#125;
&#125;
</code></pre>
<p>当当当，这样就OK了。开发中在BaseActivity这样的超类统一实现后，再在需要退出的地方调用exit方法就可以退出应用了。</p>
<pre><code class="java">public abstract class BaseActivity extends AppCompatActivity
&#123;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState)
    &#123;
        super.onCreate(savedInstanceState);
        MyApplication.getInstance().addActivity(this);
    &#125;
  //...
    @Override
    protected void onDestroy()
    &#123;
        super.onDestroy();
        MyApplication.getInstance().removeActivity(this);
    &#125;
 //...
&#125;
</code></pre>
<h2 id="广播式"><a href="#广播式" class="headerlink" title="广播式"></a>广播式</h2><p>在BaseActivity这样超类中注册一个广播，要退出时发送一个广播，就可以结束所有页面了。</p>
<pre><code class="java">public abstract class BaseActivity extends AppCompatActivity
&#123;

    private static final String EXITACTION = &quot;action.exit&quot;;

    private ExitReceiver exitReceiver = new ExitReceiver();

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        IntentFilter filter = new IntentFilter();
        filter.addAction(EXITACTION);
        LocalBroadcastManager.getInstance(this).registerReceiver(exitReceiver, new IntentFilter(EXITACTION));
    &#125;

    @Override
    protected void onDestroy() &#123;
        super.onDestroy();
        LocalBroadcastManager.getInstance(this).unregisterReceiver(exitReceiver);
    &#125;

    class ExitReceiver extends BroadcastReceiver
    &#123;
        @Override
        public void onReceive(Context context, Intent intent) &#123;
            BaseActivity.this.finish();
        &#125;
    &#125;
&#125;
</code></pre>
<p>发送广播的代码就不贴啦，上面的代码用的是本地广播，效率和安全性高一点。</p>
<h2 id="标志式"><a href="#标志式" class="headerlink" title="标志式"></a>标志式</h2><p>就是在工具类或者配置类里定义一个静态的成员属性</p>
<pre><code class="java">public class Config
&#123;
    public static final Boolean isExit =false;
//...
&#125;
</code></pre>
<p>然后在BaseActivity的onResume方法中做判断就可以了。</p>
<pre><code class="java">public abstract class BaseActivity extends AppCompatActivity
&#123;
  @Override
  onResume() &#123;
     super.onResume();
     if(Config.isExit) finish();
  &#125;
//...
&#125;
</code></pre>
<h2 id="Intent-FLAG式"><a href="#Intent-FLAG式" class="headerlink" title="Intent.FLAG式"></a>Intent.FLAG式</h2><p>在startActivity的时候，可以在intent附加一些flag信息来控制Acitivity的启动模式，里面呢有一个FLAG_ACTIVITY_CLEAR_TASK的flag，根据文档的说明，它在启动目标Acitivity的时候会清空之前所有任务关联的Acitivity，嘿嘿，这不就我们想要的效果么，所以我们完全可以利用这个启动模式来做退出功能。我们只要建立一个ExitAcitivity。</p>
<pre><code class="java">public class ExitAcitivity extends AppCompatActivity
&#123;

    @Override
    protected void onCreate(Bundle savedInstanceState)
    &#123;
        super.onCreate(savedInstanceState);
        finish();
    &#125;
&#125;
</code></pre>
<p>然后呢，要退出的时候，通过前面提到的FLAG_ACTIVITY_CLEAR_TASK来启动这个Activity就可以啦。</p>
<pre><code class="java">public void onClick(View v)
&#123;
    Intent intent = new Intent(this, ExitAcitivity .class);
    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    startActivity(intent);
&#125;
</code></pre>
<p>文档中说明FLAG_ACTIVITY_CLEAR_TASK要与FLAG_ACTIVITY_NEW_TASK一起使用，应该是底层实现的时候就直接把之前的Task给杀掉了。通过这种方式我们也可以简单的实现退出应用的功能，当然利用Activity的singleTask启动模式也是可以的哦。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实我一直觉得思维才是一个人的能力体现（啦啦啦，不装逼我们还是好朋友），虽然这只是一个简单的例子，但是很多时候，有些问题，你只要换一个角度去思考就迎刃而解了。所以写这些东西也是为了跟大家交流然后扩展自己的见解，那么，大家还有其他方法么，欢迎指导交流哦。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>AngularJS简单介绍</title>
    <url>/2016/10/08/AngularJS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>AngularJS是一款优秀的前端框架，主要解决hmtl在构建web应用上不足的问题。AngularJS核心的特点是模块化，数据的双向绑定，依赖注入。</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>在html标签中使用ng-app指示符定义一个模块</p>
<pre><code class="html">&lt;html ng-app=&quot;mall-app&quot; style=&quot;height: 100%;&quot;&gt;                   
</code></pre>
<span id="more"></span>
<p>然后在js代码中即可通过下angular.module()方法创建指定的模块。</p>
<pre><code class="js">var mallApp = angular.module(&#39;mall-app&#39;, []);
</code></pre>
<p>在angular的设计中，一个module是多个服务，指示符，过滤器和配置信息的集合，一般来说就是一个app或者lib了。上面的方法还有一点要说明的就是一个参数的时候是获取已经存在的module</p>
<pre><code class="js">var mallApp = angular.module(&#39;mall-app&#39;);//获取之前创建的module对象
//多次调用两个参数的方法，将创建多个对象。
</code></pre>
<p>当然有时候你的module需要依赖其他module，在创建的时候需要在第二个参数中传入依赖module的名称</p>
<pre><code class="js">var mallApp = angular.module(&#39;mall-app&#39;, [&#39;ngRoute&#39;]);//依赖官方的路由模块
</code></pre>
<p>这里额外说明一点,如果你未创建指定的module，却使用一个参数的方法去获取已经存在的module，angularjs会报错的。</p>
<pre><code class="js">var mallApp = angular.module(&#39;mall-app&#39;, []);//要先创建
var mallApp = angular.module(&#39;mall-app&#39;);//这里才能获取
</code></pre>
<h2 id="数据的双向绑定"><a href="#数据的双向绑定" class="headerlink" title="数据的双向绑定"></a>数据的双向绑定</h2><p>使用angularjs我们可以很方便的将数据绑定到html页面上，首先我们要先认识几个指示符</p>
<pre><code class="js">ng-app //之前说过的，定义一各module
ng-controler //定义一各控制器，我们可通过该控制器，控制html中的变量
ng-model //将元素值（比如输入框）绑定到变量中
</code></pre>
<p>然后呢，再介绍一下angularjs的表达式</p>
<pre><code class="html">&#123;&#123; expression &#125;&#125;//也就是ng-bind
</code></pre>
<p>介绍完之后，我们就可以开始了</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; //定义module和控制器
&lt;input ng-model=&quot;name&quot;&gt;//使用ng-model指示符，直接将元素的值帮到变量上
&lt;h1&gt;我的名字是 &#123;&#123;name&#125;&#125;&lt;/h1&gt;//表达式的变量
&lt;/div&gt;
&lt;script&gt;
var app = angular.module(&#39;myApp&#39;, []);
app.controller(&#39;myCtrl&#39;, function($scope) &#123;//获得控制器
    $scope.name = &quot;John Dow&quot;;//在js中通过$scope获取html中的变量，并赋初值
&#125;);
&lt;/script&gt;
&lt;p&gt;当你修改输入框中的值时，会影响到模型(model),当然也会影响到控制器对应的属性值。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>有兴趣的同学可以运行看一下，在输入框输入的值，会直接绑定到变量上，在hmtl上显示出来，当然name的值也会绑定到输入框中，这就是数据的双向绑定啦。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>依赖注入是软体中的一个设计模式，这种模式通过分离了客户端依赖创建的行为，使程序变得松耦合。angularjs提供了很好的依赖注入机制，通过以下5个核心组件作为依赖注入。</p>
<ul>
<li>constants<br>constant(常量)用来在配置阶段传递数值，注意这个常量在配置阶段是不可用的。</li>
<li>value<br>Value 是一个简单的 javascript 对象，用于向控制器传递值（配置阶段）</li>
<li>factory<br>factory 是一个函数用于返回值。在 service 和 controller 需要时创建。<br>通常我们使用 factory 函数来计算或返回值。</li>
<li>service<br>同factory，与factory的区别是返回时使用new关键字</li>
<li>provider<br>  AngularJS 中通过 provider 创建一个 service、factory等(配置阶段)。<br>Provider 中提供了一个 factory 方法 get()，它用于返回 value/service/factory。</li>
</ul>
<p>下面是一些代码示例</p>
<pre><code class="html">&lt;html&gt;
   
   &lt;head&gt;
      &lt;meta charset=&quot;utf-8&quot;&gt;
      &lt;title&gt;AngularJS  依赖注入&lt;/title&gt;
   &lt;/head&gt;
   
   &lt;body&gt;
      &lt;h2&gt;AngularJS 简单应用&lt;/h2&gt;
      
      &lt;div ng-app = &quot;mainApp&quot; ng-controller = &quot;CalcController&quot;&gt;
         &lt;p&gt;输入一个数字: &lt;input type = &quot;number&quot; ng-model = &quot;number&quot; /&gt;&lt;/p&gt;
         &lt;button ng-click = &quot;square()&quot;&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt;
         &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt;
      &lt;/div&gt;
      
      &lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;
      
      &lt;script&gt;
         var mainApp = angular.module(&quot;mainApp&quot;, []);
         
         mainApp.config(function($provide) &#123;
            $provide.provider(&#39;MathService&#39;, function() &#123;
               this.$get = function() &#123;
                  var factory = &#123;&#125;;
                  
                  factory.multiply = function(a, b) &#123;
                     return a * b;
                  &#125;
                  return factory;
               &#125;;
            &#125;);
         &#125;);
            
         mainApp.value(&quot;defaultInput&quot;, 5);
         
         mainApp.factory(&#39;MathService&#39;, function() &#123;
            var factory = &#123;&#125;;
            
            factory.multiply = function(a, b) &#123;
               return a * b;
            &#125;
            return factory;
         &#125;);
         
         mainApp.service(&#39;CalcService&#39;, function(MathService)&#123;
            this.square = function(a) &#123;
               return MathService.multiply(a,a);
            &#125;
         &#125;);
         
         mainApp.controller(&#39;CalcController&#39;, function($scope, CalcService, defaultInput) &#123;
            $scope.number = defaultInput;
            $scope.result = CalcService.square($scope.number);

            $scope.square = function() &#123;
               $scope.result = CalcService.square($scope.number);
            &#125;
         &#125;);
            
      &lt;/script&gt;
      
   &lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>LOL英雄联盟攻略</title>
    <url>/2021/12/01/LOL%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<img src="/2021/12/01/LOL%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E6%94%BB%E7%95%A5/2.webp" class=""> 

<h2 id="兵线"><a href="#兵线" class="headerlink" title="兵线"></a>兵线</h2><h3 id="兵线时间"><a href="#兵线时间" class="headerlink" title="兵线时间"></a>兵线时间</h3><p><code>1分05秒</code>出兵，中线小兵<code>1分30秒</code>交汇，边线小兵<code>1分40秒</code>交汇。也就是说中线小兵<code>25秒</code>到线上，边线小兵<code>35秒</code>到线上，每<code>30秒</code>刷一波线，<code>14分钟</code>(前期)前每<code>3</code>波出炮车线，<code>14分钟</code>到<code>25分钟</code>(中期)每<code>2</code>波出炮车线，<code>25分钟</code>(后期)以后每波出炮车线</p>
<span id="more"></span> 
<h3 id="兵线经济"><a href="#兵线经济" class="headerlink" title="兵线经济"></a>兵线经济</h3><p>近战兵<code>21</code>金币，远程兵<code>14</code>金币，炮车<code>64</code>金币(16分钟后<code>90</code>金币)，10分钟满刀<code>107</code>左右，线钱最多<code>2105</code>金币，工资<code>1040</code>金币，有工资装<code>1140</code>金币，往后每10分钟<code>1200</code>金币（差不多每<code>10</code>秒<code>20</code>金币）</p>
<h3 id="兵线经验"><a href="#兵线经验" class="headerlink" title="兵线经验"></a>兵线经验</h3><p>单人线，只吃线的话，第<code>2</code>波线吃<code>1</code>兵到<code>2级</code>，第<code>3</code>波线吃<code>2</code>近战兵或<code>1</code>个炮车<code>1</code>个近战到<code>3级</code>，<code>5分钟</code>第<code>3</code>波炮车线吃<code>1</code>近战兵或炮车到<code>6级</code></p>
<p>双人线，只吃线的话，第<code>2</code>波线吃<code>3</code>个近战兵到<code>2级</code>，第<code>4</code>波线到<code>3级</code>，<code>7分钟</code>第<code>13</code>波吃<code>3</code>近战兵<code>1</code>远程兵到<code>6级</code></p>
<h3 id="兵线控制"><a href="#兵线控制" class="headerlink" title="兵线控制"></a>兵线控制</h3><ul>
<li><code>放线</code>交汇前拉所有小兵仇恨或者对线时让对方吸引到己方小兵仇恨</li>
<li><code>屯兵</code>先杀远程兵</li>
<li><code>控线</code>保证对方远程兵比己方多3个，炮车线多4个</li>
</ul>
<h3 id="防御塔"><a href="#防御塔" class="headerlink" title="防御塔"></a>防御塔</h3><p><code>14分钟</code>掉外塔皮，塔皮有<code>5</code>层，每打<code>1000</code>血掉一层塔皮，每层<code>160</code>金币(相当于一波炮车线收益)，多人平分，最后<code>1</code>层塔皮<code>210</code>金币，塔<code>250</code>金币，一血塔<code>400</code>金币，<code>14分钟</code>前推塔收益<code>1100</code>金币(相当于<code>10</code>波线左右)</p>
<h2 id="野区"><a href="#野区" class="headerlink" title="野区"></a>野区</h2><ul>
<li>buff怪<code>1:30</code>开始刷新，击杀后每<code>5分钟</code>刷新一次，其他小怪<code>1:40</code>开始刷新，击杀后每<code>2分钟</code>刷新一次，河道蟹<code>3:15</code>上下同时刷新，后续<code>150s</code>刷新一只(随机一方)</li>
<li>小龙<code>5:00</code>开始刷新，击杀后<code>5分钟</code>刷新一次，风龙减大招CD<code>10%</code>，土龙加双抗<code>8%</code>，水龙每秒恢复<code>3%</code>已损失生命，火龙双伤加<code>5%</code>，第三只小龙之后，只刷新改变地形的那条龙，4只小龙得到龙魂，风龙魂加移速，土龙魂护盾，火龙魂AOE普攻伤害，水龙攻击恢复生命和法力值，远古龙拿到龙魂后的<code>6分钟</code>后刷新，buff时间<code>3分钟</code>，伤害带燃烧，<code>20%</code>血量斩杀</li>
<li>峡谷先锋<code>8:00</code>开始刷新，击杀后每<code>6分钟</code>刷新一次</li>
<li>男爵<code>20:00</code>开始刷新，击杀后每<code>6分钟</code>刷新一次，buff时间<code>3分钟</code>,提升双攻击，附近小兵强度，强化回城，打大龙时最近英雄会受到debuff限制输出</li>
</ul>
<h2 id="战法收集"><a href="#战法收集" class="headerlink" title="战法收集"></a>战法收集</h2><h3 id="英雄定位"><a href="#英雄定位" class="headerlink" title="英雄定位"></a>英雄定位</h3><ul>
<li>战士英雄，能持续作战，在一定时间作战后会越来越强比如诺手血怒武器攻速，或成长以后技能cd较短甚至有一定机动性，比如剑魔锐雯，缺点要嘛容易被风筝拉扯要嘛需要等级装备</li>
<li>开团英雄，拥有不错的控制能力，和便于控制能力发挥的位移能力，比如木木，缺点伤害和坦度不可兼得</li>
<li>坦克英雄，擅长降低受到的伤害，比如盖伦</li>
<li>爆发英雄，技能伤害较高，比如小法师</li>
<li>长手英雄，技能距离或平a距离比较长，通常技能cd也比较短，但伤害不足，害怕被近身</li>
<li>刺客英雄，优秀的机动性和爆发能力，但技能CD期间比较乏力，比如劫</li>
<li>前期英雄，靠技能输出的ad英雄，比如奥巴马，单体输出高的ap英雄，比如小鱼人</li>
<li>后期英雄，靠攻速平a特效输出的ad英雄，比如天使剑圣，aoe输出高的ap英雄比如发条<br>英雄定位决定你这局怎么玩<h3 id="游走"><a href="#游走" class="headerlink" title="游走"></a>游走</h3>游走gank不一定要去线上，也可以入侵对方野区，对方丢失外塔后，可以有很长的时间来游走，入侵野区支援线上，优势方的野区入侵，一般来说对方不好处理，应战的话本来劣势容易死，不应战资源被掠夺，然后中路团战，掉塔的一方需要回去二塔处理兵线，支援必然就更慢<h3 id="走位"><a href="#走位" class="headerlink" title="走位"></a>走位</h3>往一个方向走的时候，鼠标移回身后，看到技能的时候，点一下往回走<h3 id="打野"><a href="#打野" class="headerlink" title="打野"></a>打野</h3></li>
</ul>
<p>河蟹小龙需要团队支持</p>
<p>插眼位置：<br>红区<img src="/2021/12/01/LOL%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E6%94%BB%E7%95%A5/3.jpg" class="" width="300"><br>蓝区<img src="/2021/12/01/LOL%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E6%94%BB%E7%95%A5/4.jpg" class="" width="300"><br>前期饰品眼<code>60秒</code>，冷却时间<code>180秒</code></p>
<p>中路没2塔的时候，野区就相当于中立野区</p>
<p>双排套路，打野玩赵信盲僧蜘蛛豹女等肉食性打野，中上玩前中期强势英雄，明确谁要c，比如上野，只抓一路，线上优势之后，推线入侵野区，活动只在上半野区，到10分钟打先锋，打完放上路让c的人吃经济，然后继续连体，直到推掉2塔，c的人领先两大件，开团。</p>
<h3 id="辅助"><a href="#辅助" class="headerlink" title="辅助"></a>辅助</h3><p>辅助不一定要辅助adc,辅助最能c的那个人</p>
<h3 id="中期"><a href="#中期" class="headerlink" title="中期"></a>中期</h3><p>中期优势的时候应该逼团开团，优先级：大小龙，推线，抓单。劣势的时候应该避免团战，做好大小龙眼位，在安全区发育，大小龙刷新前<code>20s</code>做好眼位，打不过对面就不要硬接团战，提前有视野的情况下看能不能抓死落单的。确定拿不到大小龙就及时止损，去推大小龙比较远的线。</p>
<h3 id="团战"><a href="#团战" class="headerlink" title="团战"></a>团战</h3><p>团战要拉扯，要找到一个比较好的机会，考虑到对方技能和对方保护，能打到自己想打的人，队友也可以跟上，<br>大后期打团都是保住ad输出，不管是坦克还是上单，已经没办法很好切后排了<br>团战赢之后优先推水晶，再拿大小龙，最后掠夺野区</p>
<h3 id="单带"><a href="#单带" class="headerlink" title="单带"></a>单带</h3><p>一定是要优于对方的，一个防不住你，两个抓不死你，至少来三个，这样单带才有意义</p>
<h3 id="换线"><a href="#换线" class="headerlink" title="换线"></a>换线</h3><p>下路大优并推掉外塔之后，可以换线到上路，二打一对方上单一般来说也是打不过的，他不换会丢掉优势或者变劣势，换去下路，重复之前，打垮对面双人组，拿掉外塔和先锋</p>
<h2 id="英雄攻略"><a href="#英雄攻略" class="headerlink" title="英雄攻略"></a>英雄攻略</h2><p>3级大部分英雄的血量在<code>700</code>左右，6级的血量在<code>1000</code>左右，10级的血量在<code>1300</code>左右，每级的成长血量在<code>85</code>左右</p>
<h3 id="阿卡丽"><a href="#阿卡丽" class="headerlink" title="阿卡丽"></a>阿卡丽</h3> <img src="/2021/12/01/LOL%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E6%94%BB%E7%95%A5/1.webp" class=""> 

<p> 6级前比较弱，血少，能量不够，有w有e的时候不容易被抓，6级后到中期比较强势，多游走，可以去入侵野区，有巫妖后eeq伤害很高，团战比较容易切后排，但不要先手，大后期刺客优势降低，在于对面装备都好了，切入容易暴毙，自己伤害又是单体，一套输出有限</p>
<!-- #### 对线战法

|  英雄   | 敌人战法  | 我方战法 | 
|  ----   | ----     |   ----   |
|   亚索  |  -       | -      |


__前期关键数值如下表:__

|  等级   | 装备  | 天赋 | 连招 | 召唤师技能 | 对敌伤害/敌方魔防 |自身生命值 | 技能真空期战力
|  ----  | ----  |  ----  | ----  | ----  | ----  | ----  | ----  |
| 1  | - | 电刑 | - | - | 137/40 | 500 | 弱
| 1  | - | 电刑 | - | 点燃 | 207/40 | 500 | 弱
| 3 | - | 电刑 | eeqwaqa | - | 549/40 | 735 | 弱
| 3 | - | 电刑 | eeqwaqa | 点燃 | __659__/40 | __735__ | 弱
| 6 | - | 电刑 | - | - | 808/40 | 995 | 弱
| 6 | - | 电刑 | arqeeqr | 点燃 | __978__/40 | __995__ | 弱

根据数值和英雄特性可知，阿卡丽前期换血能力较弱，需要打出被动，所以出门两个回复宝珠，4瓶血药，苟到6级是最好的，6级以后爆发高，可以开始杀人游走，优先切脆皮

有了神话装备后，以 __火箭腰带__ 为例：

|  等级   | 装备  | 天赋 | 连招 | 召唤师技能 | 对敌伤害/敌方魔防 |自身生命值 | 技能真空期战力
|  ----  | ----  |  ----  | ----  | ----  | ----  | ----  | ----  |
| 6 | - | 电刑 | arqeeqr | 点燃 | __978__/40 | 995 | 弱
| 8  | 腰带 | 电刑 | arqeeqr | 点燃 | __1745__/50 | 1357 | 弱
| 8  | 腰带 | 电刑 | eeq | - | __747__/50 | 1357 | 弱

此时伤害相对于刚到6级提升`78%`左右，__火箭腰带__`3200`金币

有了 __法穿鞋__ 之后：

|  等级   | 装备  | 天赋 | 连招 | 召唤师技能 | 对敌伤害/敌方魔防 |自身生命值 | 技能真空期战力
|  ----  | ----  |  ----  | ----  | ----  | ----  | ----  | ----  |
| 8  | 腰带 | 电刑 | arqeeqr | 点燃 | __1745__/50 | 1357 | 弱
| 8  | 腰带、法穿鞋 | 电刑 | arqeeqr | 点燃 | __1980__/50 | 1357 | 弱
| 8  | 腰带 | 电刑 | eeq | - | __747__/50 | 1357 | 弱
| 8  | 腰带、法穿鞋 | 电刑 | eeq | - | __845__/50 | 1357 | 弱

伤害提升`13%`,鞋子合成 __法穿鞋__ 需要`800`金币

有了 __巫妖__ 之后：

|  等级   | 装备  | 天赋 | 连招 | 召唤师技能 | 对敌伤害/敌方魔防 |自身生命值 | 技能真空期战力
|  ----  | ----  |  ----  | ----  | ----  | ----  | ----  | ----  |
| 8  | 腰带、法穿鞋 | 电刑 | arqeeqr | 点燃 | __1980__/50 | 1563 | 弱
| 10  | 腰带、法穿鞋、巫妖 | 电刑 | arqeeqr | 点燃 | __2780__/50 | 1563 | 弱
| 10  | 腰带、法穿鞋 | 电刑 | eeq | - | __845__/50 | 1563 | 弱
| 10  | 腰带、法穿鞋、巫妖 | 电刑 | eeq | - | __1326__/50 | 1563 | 弱

一套伤害提升大概`40%`左右，__巫妖__`3000金币`，但eeq连招伤害提升有`56%`，此时adc的血量估计应该在`1300`左右，魔防`30+`，eeq可秒~

对面有 __魔防__ 的情况：

|  等级   | 装备  | 天赋 | 连招 | 召唤师技能 | 对敌伤害/敌方魔防 |自身生命值 | 技能真空期战力
|  ----  | ----  |  ----  | ----  | ----  | ----  | ----  | ----  |
| 10  | 腰带、法穿鞋、巫妖 | 电刑 | 腰带arqeeqr | 点燃 | __2884__/__50__ | 1563 | 弱
| 10  | 腰带、法穿鞋、巫妖 | 电刑 | 腰带arqeeqr | 点燃 | __2202__/__100__ | 1563 | 弱
| 10  | 腰带、法穿鞋、巫妖 | 电刑 | 腰带arqeeqr | 点燃 | __1547__/__150__ | 1563 | 弱
| 10  | 腰带、法穿鞋、巫妖 | 电刑 | eeq | - | __1326__/__50__ | 1563 | 弱
| 10  | 腰带、法穿鞋、巫妖 | 电刑 | eeq | - | __939__/__100__ | 1563 | 弱
| 10  | 腰带、法穿鞋、巫妖 | 电刑 | eeq | - | __702__/__150__ | 1563 | 弱

对方有`100`魔防的话， 伤害大概减为`70%`,对方有`150`魔防的话，伤害大概减为`50%`，所以对方定位不是坦克，没有护盾和减伤技能的话，就算魔防达到`100`，血量在`2200`左右也是可以杀的，`150`魔防以上的就算了吧，太费劲了

然后是 __第三件装备__ 的选择对比：

|  等级   | 装备  | 天赋 | 连招 | 召唤师技能 | 对敌伤害/敌方魔防 |自身生命值 | 技能真空期战力
|  ----  | ----  |  ----  | ----  | ----  | ----  | ----  | ----  |
| 13  | 腰带、法穿鞋、巫妖、`星界` | 电刑 | eeq | - | 1877/50 | 2100 | 弱
| 13  | 腰带、法穿鞋、巫妖、`星界` | 电刑 | 腰带arqeeqra | 点燃 | 4572/50 | 2100 | 弱
| 13  | 腰带、法穿鞋、巫妖、`中娅` | 电刑 | eeq | - | 1824/50 | 1900 | 弱
| 13  | 腰带、法穿鞋、巫妖、`中娅` | 电刑 | 腰带arqeeqra | 点燃 | 4168/50 | 1900 | 弱
| 13  | 腰带、法穿鞋、巫妖、`女妖` | 电刑 | eeq | - | 1765/50 | 1900 | 弱
| 13  | 腰带、法穿鞋、巫妖、`女妖` | 电刑 | 腰带arqeeqra | 点燃 | 4253/50 | 1900 | 弱

__星界__ `3000`金币，__中娅__ `2600`金币，__女妖__ `2600` 金币，__星界__ 伤害比较高(被动加法强和移动速度)，还有固定技能急速和移动速度属性，很适合阿卡丽，如果对面有开团和致命技能的话，出女妖和中娅比较合适，伤害少`10%`左右

`神装`以后

|  等级   | 装备  | 天赋 | 连招 | 召唤师技能 | 对敌伤害/敌方魔防 |自身生命值 | 技能真空期战力
|  ----  | ----  |  ----  | ----  | ----  | ----  | ----  | ----  |
| 18  | 腰带、法穿鞋、巫妖、星界、女妖、帽子 | 电刑 | eeq | - | `3347`/50 | 2736 | 弱
| 18  | 腰带、法穿鞋、巫妖、星界、女妖、帽子 | 电刑 | 腰带arqeeqra | 点燃 | `8455`/50 | 2736 | 弱

神装以后爆发很高，eeq就能有`3300+`的伤害，秒脆皮是没什么问题的，但要注意入场的时机，和对面后排的保护 -->


<p><strong>技能使用技巧 ：</strong></p>
<ul>
<li>可以q闪，可以e闪</li>
<li>金身、闪现、q<code>不取消</code>e2</li>
<li>r1、r2、腰带<code>取消</code>e2平a</li>
<li>q完a闪触发被动（我打不出来- -）</li>
<li>w可以侦测敌方(方向移动)</li>
<li>r1距离不是固定的</li>
<li>r1跳起后可施放技能</li>
<li>一套连招arqeeqr，r之前先下达平a指令，这样rq后会自动平a</li>
</ul>
<h3 id="锐雯"><a href="#锐雯" class="headerlink" title="锐雯"></a>锐雯</h3><p>前期较弱，比较依赖装备，优势在于机动性，拉扯技能，中后期cd短比较强势，打团切后排能力一般，技能全突到c位脸上则伤害乏力，在于持续作战</p>
<p> <strong>技能使用技巧 ：</strong></p>
<ul>
<li>注意鼠标指针，先把q打准了</li>
<li>w硬直很大，无法自动平a</li>
<li>e之后可用技能取消读条技能，效果一秒左右(核心)</li>
<li>q取消a后摇，移动取消q后摇(核心)</li>
<li>连招：eawaq，erwqaqaqra，er3awqa，erawqa，erqaw渴血r</li>
</ul>
<h3 id="李青"><a href="#李青" class="headerlink" title="李青"></a>李青</h3><p>前期强势，在于技能多，使用技能后攻速提升，能量机制无消耗，刷野效率较快，野区中战力较强，比较灵活，但没有爆发，定位战士打法，q中再上，留w回来，团战中r角度可以团控，而且不是有w有闪就可以r回敌方的，需要注意距离，后期乏力在于输出和扛伤上不再优势，作为刺客踢回后排风险大收益大，比较考验熟练度</p>
<p> <strong>技能使用技巧 ：</strong></p>
<ul>
<li>摸眼的速度在于对距离的把控</li>
</ul>
<h3 id="永恩"><a href="#永恩" class="headerlink" title="永恩"></a>永恩</h3><p>刺客战士定位，有较多位移技能，可以切入后排，也可以及时脱险，但突进技能有延迟性，需要意识和熟练度，没有爆发需要打出持续伤害，就是比较依赖装备，有一定的清线和换血能力，6级团战能力较强，但最好打反手，后期也较强势，刺客的劣势在于逆风局势下很难作为，一旦优势期失去节奏，不好翻身</p>
<p> <strong>技能使用技巧 ：</strong></p>
<ul>
<li>无法r闪</li>
<li>e2可以解除多种控制，于控制前返回</li>
</ul>
<h3 id="赛娜"><a href="#赛娜" class="headerlink" title="赛娜"></a>赛娜</h3><p>ad型辅助，手长，能恢复，有控制</p>
<p> <strong>技能使用技巧 ：</strong></p>
<ul>
<li>q可以作用于任何可以a的东西</li>
</ul>
]]></content>
      <categories>
        <category>游戏攻略</category>
      </categories>
      <tags>
        <tag>LOL</tag>
        <tag>英雄联盟</tag>
      </tags>
  </entry>
  <entry>
    <title>WebView加载速度优化</title>
    <url>/2016/05/25/WebView%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>在做混合应用的时候，有几个痛点，一个是无网络无法使用，还有一个是受网络环境影响的网页加载速度。今天就这两个问题，和大家交流一下自己的经验。</p>
<h2 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h2><p>这个比较容易，开启webView的缓存功能就可以了。</p>
<pre><code class="java">WebSettings settings = webView.getSettings();
settings.setAppCacheEnabled(true);
settings.setDatabaseEnabled(true);
settings.setDomStorageEnabled(true);//开启DOM缓存，关闭的话H5自身的一些操作是无效的
settings.setCacheMode(WebSettings.LOAD_DEFAULT);
</code></pre>
<span id="more"></span>
<p>这边我们通过setCacheMode方法来设置WebView的缓存策略，WebSettings.LOAD_DEFAULT是默认的缓存策略，它在缓存可获取并且没有过期的情况下加载缓存，否则通过网络获取资源。这样的话可以减少页面的网络请求次数，那我们如何在离线的情况下也能打开页面呢，这里我们在加载页面的时候可以通过判断网络状态，在无网络的情况下更改webview的缓存策略。</p>
<pre><code class="java">ConnectivityManager cm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
NetworkInfo info = cm.getActiveNetworkInfo();
if(info.isAvailable())
&#123;
    settings.setCacheMode(WebSettings.LOAD_DEFAULT);
&#125;else 
&#123;
    settings.setCacheMode(WebSettings.LOAD_CACHE_ONLY);//不使用网络，只加载缓存
&#125;
</code></pre>
<p>这样我们就可以使我们的混合应用在没有网络的情况下也能使用一部分的功能，不至于什么都显示不了了，当然如果我们将缓存做的更好一些，<strong>在网络好的时候，比如说在WIFI状态下，去后台加载一些网页缓存起来，这样处理的话，即使在无网络情况下第一次打开某些页面的时候，也能将该页面显示出来。</strong><br>当然缓存资源后随之会带来一个问题，那就是资源无法及时更新，WebSettings.LOAD_DEFAULT中的页面中的缓存版本好像不是很起作用，所以我们这边可能需要自己做一个缓存版本控制。这个缓存版本控制可以放在APP版本更新中。</p>
<pre><code class="java">if (upgrade.cacheControl &gt; cacheControl)
&#123;
    webView.clearCache(true);//删除DOM缓存
    VersionUtils.clearCache(mContext.getCacheDir());//删除APP缓存
    try
    &#123;
        mContext.deleteDatabase(&quot;webview.db&quot;);//删除数据库缓存
        mContext.deleteDatabase(&quot;webviewCache.db&quot;);
    &#125;
    catch (Exception e)
    &#123;
    &#125;
&#125;
</code></pre>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>有时候一个页面资源比较多，图片，CSS，js比较多，还引用了JQuery这种庞然巨兽，从加载到页面渲染完成需要比较长的时间，有一个解决方案是将这些资源打包进APK里面，然后当页面加载这些资源的时候让它从本地获取，这样可以提升加载速度也能减少服务器压力。重写WebClient类中的shouldInterceptRequest方法，再将这个类设置给WebView。</p>
<pre><code class="java">webView.setWebViewClient(new WebViewClient()
&#123;

    @Override
    public WebResourceResponse shouldInterceptRequest(WebView view, String url)
    &#123;
        if (url.contains(&quot;[tag]&quot;))
        &#123;
            String localPath = url.replaceFirst(&quot;^http.*[tag]\\]&quot;, &quot;&quot;);
            try
            &#123;
                InputStream is = getApplicationContext().getAssets().open(localPath);
                Log.d(TAG, &quot;shouldInterceptRequest: localPath &quot; + localPath);
                String mimeType = &quot;text/javascript&quot;;
                if (localPath.endsWith(&quot;css&quot;))
                &#123;
                    mimeType = &quot;text/css&quot;;
                &#125;
                return new WebResourceResponse(mimeType, &quot;UTF-8&quot;, is);
            &#125;
            catch (Exception e)
            &#123;
                e.printStackTrace();
                return null;
            &#125;
        &#125;
        else
        &#123;
            return null;
        &#125;

    &#125;
&#125;);
</code></pre>
<p>这里我们队页面中带有特殊标记的请求进行过滤替换，也就是上面代码中的[tag]，这个可以跟做后台开发的同事约定好来就行了。对图片资源或者其他资源进行替换也是可以的。补充一个小点可以通过settings.setLoadsImagesAutomatically(true);来设置在页面装载完成之后再去加载图片。</p>
<h2 id="H5优化"><a href="#H5优化" class="headerlink" title="H5优化"></a>H5优化</h2><p>Android的OnPageFinished事件会在Javascript脚本执行完成之后才会触发。如果在页面中使 用JQuery，会在处理完DOM对象，执行完**$(document).ready(function() {});**事件自会后才会渲染并显示页面。而同样的页面在iPhone上却是载入相当的快，因为iPhone是显示完页面才会触发脚本的执行。所以我们这边的解决方案延迟JS脚本的载入，这个方面的问题是需要Web前端工程师帮忙优化的，网上应该有比较多LazyLoad插件，这里放一个比较老的链接<a href="http://wonko.com/post/painless_javascript_lazy_loading_with_lazyload">Painless JavaScript lazy loading with LazyLoad</a>,同样也放上一小段前端代码，仅供参考。</p>
<pre><code class="HTML">&lt;script src=&quot;/css/j/lazyload-min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
  loadComplete() &#123;
    //instead of document.read();
  &#125; 
  function loadscript() &#123;
    LazyLoad.loadOnce([
      &#39;/css/j/jquery-1.6.2.min.js&#39;,
      &#39;/css/j/flow/jquery.flow.1.1.min.js&#39;,
      &#39;/css/j/min.js?v=2011100852&#39;
      ], loadComplete);
  &#125;
  setTimeout(loadscript,10);
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10搭建Gitlab Runner</title>
    <url>/2022/03/22/Win10%E6%90%AD%E5%BB%BAGitlab%20Runner/</url>
    <content><![CDATA[ <img src="/2022/03/22/Win10%E6%90%AD%E5%BB%BAGitlab%20Runner/cover.webp" class="">

<h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h2><p><strong>持续集成（CI）</strong>是在源代码变更后自动检测、拉取、构建和（在大多数情况下）进行单元测试的过程。<br><strong>持续交付（CD）</strong>通常是指整个流程链（管道），它自动监测源代码变更并通过构建、测试、打包和相关操作运行它们以生成可部署的版本<br>持续交付包含持续集成（自动检测源代码变更、执行构建过程、运行单元测试以验证变更），持续测试（对代码运行各种测试以保障代码质量），和（可选）持续部署（通过管道发布版本自动提供给用户）。</p>
<h2 id="gitlab-使用"><a href="#gitlab-使用" class="headerlink" title="gitlab 使用"></a>gitlab 使用</h2><p>gitlab 一般是公司搭建的，如果公司还搭建了<code>Shared runners</code>那么就可以开始捣鼓<code>CI/CD</code>了，没有的话，就可以在自己的服务器或 pc 上搭建了。<br>在 gitlab 指定项目的<code>setting</code>中找到<code>CI/CD</code><br> <img src="/2022/03/22/Win10%E6%90%AD%E5%BB%BAGitlab%20Runner/1.png" class=""><br>在页面中展开<code>runner</code>选项，可以看到项目的独立 token<br> <img src="/2022/03/22/Win10%E6%90%AD%E5%BB%BAGitlab%20Runner/2.png" class=""></p>
<span id="more"></span>   

<h2 id="下载-Git-Runner"><a href="#下载-Git-Runner" class="headerlink" title="下载 Git Runner"></a>下载 Git Runner</h2><p>去官网下载<code>Gitlab Runner</code>，<a href="https://docs.gitlab.com/runner/install/windows.html">Install GitLab Runner on Windows</a>，<br>下载完成后可以重命名一下<code>gitlab-runner.exe</code>，主要方便后续操作，找到该目录或者放到一个指定目录<br> <img src="/2022/03/22/Win10%E6%90%AD%E5%BB%BAGitlab%20Runner/3.png" class=""><br>点击左上方文件菜单以管理员身份打开<code>powershell</code><br> <img src="/2022/03/22/Win10%E6%90%AD%E5%BB%BAGitlab%20Runner/4.png" class=""><br>注册 runner</p>
<pre><code class="Bash">./gitlab-runner.exe register
</code></pre>
<p>然后出现以下内容<br> <img src="/2022/03/22/Win10%E6%90%AD%E5%BB%BAGitlab%20Runner/5.png" class=""><br>第一个是你 gitlab 的地址<br>第二个是该项目的独立 token，请参考第一部分的说明<a href="./#gitlab-%E4%BD%BF%E7%94%A8">gitlab 使用</a><br>中间的 description，tags，notes 都可以放空，最后的 executor 选 shell，完成之后，在同目录下会生成一个<code>config.toml</code>，打开文件编辑<br> <img src="/2022/03/22/Win10%E6%90%AD%E5%BB%BAGitlab%20Runner/6.png" class=""><br>将上图的指示的内容改为</p>
<pre><code class="text">shell = &quot;powershell&quot;
</code></pre>
<p>然后再运行</p>
<pre><code class="Bash">.\gitlab-runner.exe install
.\gitlab-runner.exe start
</code></pre>
 <img src="/2022/03/22/Win10%E6%90%AD%E5%BB%BAGitlab%20Runner/8.png" class="">
<p>此时再去 gitlab 查看项目 setting 中的 runner 时</p>
 <img src="/2022/03/22/Win10%E6%90%AD%E5%BB%BAGitlab%20Runner/7.png" class="">
<p>已有可用的 runner，然后在 gitlab 的 CI/CD 面板中可以运行<code>run pipeline</code><br> <img src="/2022/03/22/Win10%E6%90%AD%E5%BB%BAGitlab%20Runner/9.png" class=""><br>具体执行什么任务，则是在你项目里面的<code>.gitlab-ci.yml</code>中描述<br> <img src="/2022/03/22/Win10%E6%90%AD%E5%BB%BAGitlab%20Runner/10.png" class=""></p>
]]></content>
      <categories>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>Gitlab Runner</tag>
      </tags>
  </entry>
  <entry>
    <title>android-studio-实用技巧</title>
    <url>/2016/10/10/android-studio-%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<ul>
<li><strong>打jar包</strong><br>android studio 默认提供的是aar包，如果要打成jar包的话，就要自己写gradle task，在库工程的build.gradle文件中添加一下代码：<pre><code class="java">task makeJar(type: Copy) &#123;
 delete &#39;build/libs/mysdk.jar&#39;
 from(&#39;build/intermediates/bundles/release/&#39;)
 into(&#39;build/libs/&#39;)
 include(&#39;classes.jar&#39;)
 rename (&#39;classes.jar&#39;, &#39;mysdk.jar&#39;)
&#125;
makeJar.dependsOn(build);
</code></pre>
然后在终端执行命令打出jar包<pre><code class="bash">gradlew makeJar
</code></pre>
</li>
<li><strong>引用aar包</strong><br>将aar拷贝至lib目录，在module中的build.gradle文件中添加以下代码<pre><code class="java">repositories &#123; flatDir &#123; dirs &#39;libs&#39; &#125; &#125;
dependencies &#123;
compile(name: &#39;aar_name&#39;, ext: &#39;aar&#39;)
&#125;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>charles常用技巧</title>
    <url>/2022/03/22/charles%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[ <img src="/2022/03/22/charles%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/cover.webp" class=""> 
<h2 id="Charles修改接口返回数据-Breakpoints"><a href="#Charles修改接口返回数据-Breakpoints" class="headerlink" title="Charles修改接口返回数据(Breakpoints)"></a>Charles修改接口返回数据(Breakpoints)</h2><p>可以在上方的proxy中添加需要断点的请求<br> <img src="/2022/03/22/charles%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/1.png" class=""><br>也可以直接在请求链接上右键菜单选择Breakpoints。设置完成之后，发起请求，charles会进入断点模式，如下图<br> <img src="/2022/03/22/charles%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2.png" class=""><br>这边选择<code>Edit Request</code>可以修改请求<br> <img src="/2022/03/22/charles%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/3.png" class=""><br>点击<code>Execute</code>会进去下一步，等待服务器返回，得到返回后，再次进入断点<br> <img src="/2022/03/22/charles%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/4.png" class=""><br>这边选择<code>Edit Response</code>可以修改返回<br> <img src="/2022/03/22/charles%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/5.png" class=""> </p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title>github clone 速度慢解决方案</title>
    <url>/2021/12/27/github-clone-%E9%80%9F%E5%BA%A6%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>有时候从github上clone项目速度很慢，可以将链接中域名<code>github.com</code>替换成<code>github.com.cnpmjs.org</code>,比如原先的clone url为</p>
<pre><code class="bash">https://github.com/wufan123/xxxx.git 
</code></pre>
<p>替换为</p>
<pre><code class="bash">https://github.com.cnpmjs.org/wufan123/xxxx.git
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>highlight.js使用</title>
    <url>/2021/12/23/highlight-js%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>一个web上高亮语法的js，<a href="https://highlightjs.org/">官网</a></p>
<p>使用(CDN)：</p>
<pre><code class="html">&lt;link rel=&quot;stylesheet&quot;
      href=&quot;//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/styles/default.min.css&quot;&gt;
&lt;script src=&quot;//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;hljs.highlightAll();&lt;/script&gt;
</code></pre>
<p>要更换主题的话，替换css，这边<code>default.css</code>是默认主题，要换主题的改css文件名称就可以了，参见<a href="https://highlightjs.org/static/demo/">主题列表</a>，比如要用<code>Vs 2015</code>，改成</p>
<pre><code class="html">&lt;link rel=&quot;stylesheet&quot;
      href=&quot;//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/styles/vs2015.min.css&quot;&gt;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin-学习笔记（一）</title>
    <url>/2017/06/08/kotlin-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="什么是kotlin"><a href="#什么是kotlin" class="headerlink" title="什么是kotlin"></a>什么是kotlin</h2><p>一门现代多平台应用的静态编程语言</p>
<h2 id="相对于java的优点"><a href="#相对于java的优点" class="headerlink" title="相对于java的优点"></a>相对于java的优点</h2><p>总的来说就是语法上比较简洁，更易书写和阅读，对空指针这类的错误异常更易把握，并很好兼容java</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>列出几个较java不同的地方</p>
<ul>
<li><strong>包定义</strong>，不要求包名符合文件路径，每个kotlin源文件都会默认引入kotlin一些相关包，然后根据平台的不同，引入一些平台包</li>
<li><strong>字符串模板</strong>，字符串中可以包含模板表达式，列如：<pre><code class="kotlin">val s = &quot;abc&quot;
val str = &quot;$s.length is $&#123;s.length&#125;&quot; // evaluates to &quot;abc.length is 3&quot;
</code></pre>
</li>
<li><strong>空值检查</strong>，可以通过？.来安全使用可能为空的对象。列如：<pre><code class="kotlin">val l = b?.length ?: -1
</code></pre>
</li>
</ul>
<span id="more"></span>

<ul>
<li><strong>类型转换检查</strong><pre><code class="kotlin">val aInt: Int? = a as? Int//if a  is not Int，a is null
</code></pre>
</li>
<li><strong>类型的自动转换</strong><pre><code class="kotlin">if (obj is String) &#123;
      // `obj` is automatically cast to `String` in this branch
      return obj.length
  &#125;
</code></pre>
</li>
<li><strong>for循环和while循环</strong><pre><code class="kotlin">for (item in items) &#123;
  println(item)
&#125;
for (index in items.indices) &#123;
  println(&quot;item at $index is $&#123;items[index]&#125;&quot;)
&#125;
while (index &lt; items.size) &#123;
  println(&quot;item at $index is $&#123;items[index]&#125;&quot;)
  index++
&#125;
</code></pre>
</li>
<li><strong>when</strong>表达式，类似java中switch<pre><code class="kotlin">when (obj) &#123;
  1          -&gt; &quot;One&quot;
  &quot;Hello&quot;    -&gt; &quot;Greeting&quot;
  is Long    -&gt; &quot;Long&quot;
  !is String -&gt; &quot;Not a string&quot;
  else       -&gt; &quot;Unknown&quot;
&#125;
</code></pre>
</li>
<li><strong>ranges</strong>表达式，检查某值是否在某个范围内<pre><code class="kotlin">val x = 10
val y = 9
if (x in 1..y+1) &#123;
  println(&quot;fits in range&quot;)
&#125;
</code></pre>
</li>
<li><strong>collections</strong>的使用<pre><code class="kotlin">when &#123;//hecking if a collection contains an object using in operator
  &quot;orange&quot; in items -&gt; println(&quot;juicy&quot;)
  &quot;apple&quot; in items -&gt; println(&quot;apple is fine too&quot;)
&#125;
fruits//Using lambda
.filter &#123; it.startsWith(&quot;a&quot;) &#125;
.sortedBy &#123; it &#125;
.map &#123; it.toUpperCase() &#125;
.forEach &#123; println(it) &#125;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs中的package.json文件</title>
    <url>/2021/12/27/nodejs%E4%B8%AD%E7%9A%84package-json%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>关于package.json文件的<a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json/">官方文档说明</a>,英文好的的同学可以自行前往查看，下面是对一些文件中的常见字段的说明：</p>
<h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p>项目名称，如果要发布的话，这个字段必须</p>
<h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><p>版本，同上</p>
<span id="more"></span>

<h2 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h2><p>定义了脚本命令，比如</p>
<pre><code class="json">&quot;scripts&quot;: &#123; 
     &quot;prepare&quot;: &quot;git submodule init &amp;&amp; git submodule update &amp;&amp; git submodule foreach git pull origin master&quot;
  &#125;
</code></pre>
<p>上面定义prepare脚本命令，通过<code>npm run prepare</code>执行<code>git submodule init &amp;&amp; git submodule update &amp;&amp; git submodule foreach git pull origin master</code></p>
<h2 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h2><p>项目运行依赖的模块</p>
<h2 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h2><p>项目开发所需要的模块</p>
<h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>可执行文件，会安装到系统的<code>PATH</code>中，如果是全局安装，直接使用包名即可，确保bin中的js文件是以<code>#!/usr/bin/env node</code>开头，不然会无法识别javascript语句</p>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>main字段指定了加载入口文件，<code>require()</code>加载这个文件</p>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>添加命令行的环境变量，比如</p>
<pre><code class="json">&#123;
    &quot;config&quot;:&#123;&quot;port&quot;:8080&#125;
&#125;
</code></pre>
<p>在脚本就可以使用</p>
<pre><code class="JS">process.env.npm_package_config_port
</code></pre>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>npx</title>
    <url>/2021/12/28/npx/</url>
    <content><![CDATA[<p>npm 从5.2版开始，增加了 npx 命令，主要解决的问题是调用项目内部安装的模块，比如</p>
<pre><code>npm install webpack -D
</code></pre>
<p>要调用webpack的话只能在项目脚本或者package.json的scripts字段，如果要在cli调用，要这样</p>
<pre><code class="bash">#根目录下
$ node-modules/.bin/webpack -v
</code></pre>
<p>使用npx的话可以直接调用</p>
<pre><code class="bash">npx webpack -v
</code></pre>
<p>原理是npx运行时会到<code>node_modules/.bin</code>和<code>$PATH</code>里检查命令是否存在，所以系统命令也可以调用，其他具体参见<a href="https://www.npmjs.com/package/npx">官方说明</a> </p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>npx</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode让人眼前一亮的插件</title>
    <url>/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Project-Manager"><a href="#Project-Manager" class="headerlink" title="Project Manager"></a>Project Manager</h2><p>提升切换项目的效率，上面面板是收藏功能，并且可以按标签分类，下面面板设定根目录后，会自动扫描目录下所有git/svn项目<br> <img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/1.png" class=""> </p>
<h2 id="GitHub-Repositories"><a href="#GitHub-Repositories" class="headerlink" title="GitHub Repositories"></a>GitHub Repositories</h2><p>打开远程 github 仓库，全部 clone 下来太费时间，用这个插件就可以快速打开远程仓库，按需请求文件内容，读取速度很快。右边还有列表面板。<br> <img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/6.png" class=""></p>
<h2 id="Bookmarks"><a href="#Bookmarks" class="headerlink" title="Bookmarks"></a>Bookmarks</h2><p>可以在你代码或文档中设置书签，然后通过书签进行快速的位置跳转<br> <img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/5.png" class=""> </p>
<span id="more"></span>
<h2 id="Autoprefixer"><a href="#Autoprefixer" class="headerlink" title="Autoprefixer"></a>Autoprefixer</h2><p>自动添加css前缀</p>
<h2 id="Color-Highlight"><a href="#Color-Highlight" class="headerlink" title="Color Highlight"></a>Color Highlight</h2><p>高亮颜色代码</p>
<h2 id="Blockman"><a href="#Blockman" class="headerlink" title="Blockman"></a>Blockman</h2><p>一款可以很直观的显示代码层次结构的插件<br> <img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/7.png" class=""> </p>
<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><p>笔记，可以集中管理，不影响当前正在打开的项目，适合随手记录 一些比较零碎的东西,搭配其他 markdown 插件，可以方便的实现笔记内链，图床之类的功能。<br> <img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/2.png" class=""> </p>
<h2 id="vscode-leetcode"><a href="#vscode-leetcode" class="headerlink" title="vscode-leetcode"></a>vscode-leetcode</h2><p>一个可以让用户在 VS Code 编辑器中，练习 LeetCode 习题的插件。支持：查看高票解答、提交答案、测试答案等。<br> <img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/8.png" class=""> </p>
<h2 id="Dictionary-Completion"><a href="#Dictionary-Completion" class="headerlink" title="Dictionary Completion"></a>Dictionary Completion</h2><p>字典补全，如果你需要用英文写东西，可以帮你快速补全一些记不住的长单词</p>
<h2 id="TabNine"><a href="#TabNine" class="headerlink" title="TabNine"></a>TabNine</h2><p>基于机器学习的人工智能补全工具，几乎支持任何编程语言看，通过使用AI和索引来形成最合理的代码提示，也就是你写的越多它就越懂你。但是比较占内存<br> <img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/10.png" class=""> </p>
<h2 id="Code-Runner"><a href="#Code-Runner" class="headerlink" title="Code Runner"></a>Code Runner</h2><p>代码一键运行，支持超过40种语言<br> <img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/12.png" class=""> </p>
<h2 id="Debug-Visualizer"><a href="#Debug-Visualizer" class="headerlink" title="Debug Visualizer"></a>Debug Visualizer</h2><p>调试可视化</p>
<h2 id="Atuo-Rename-Tag"><a href="#Atuo-Rename-Tag" class="headerlink" title="Atuo Rename Tag"></a>Atuo Rename Tag</h2><p>修改 html 标签，自动帮你完成尾部闭合标签的同步修改。</p>
<h2 id="Image-preview"><a href="#Image-preview" class="headerlink" title="Image preview"></a>Image preview</h2><p> 左侧显示图片预览</p>
<img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/11.png" class=""> 

<h2 id="React-Style-Helper"><a href="#React-Style-Helper" class="headerlink" title="React Style Helper"></a>React Style Helper</h2><p>帮助更快速的在JSX中实现样式，自动补全类名，自动补全内联样式，预览样式定义，自动引入</p>
<img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/15.gif" class=""> 

<h2 id="Regex-Previewer"><a href="#Regex-Previewer" class="headerlink" title="Regex Previewer"></a>Regex Previewer</h2><p>实时测试正则表达式的实用工具。它可以将正则表达式模式应用在任何打开的文件上，并高亮所有的匹配项</p>
<img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/14.png" class="">


<h2 id="Turbo-Console-Log"><a href="#Turbo-Console-Log" class="headerlink" title="Turbo Console Log"></a>Turbo Console Log</h2><p>快捷添加 console.log，一键 注释 / 启用 / 删除 所有 console.log</p>
<img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/16.gif" class="">

<p>快捷键,容易跟其他软件快捷键冲突</p>
<pre><code>ctrl + alt + l 选中变量之后，使用这个快捷键生成 console.log
alt + shift + c 注释所有 console.log
alt + shift + u 启用所有 console.log
alt + shift + d 删除所有 console.log
</code></pre>
<h2 id="vscode-fileheader"><a href="#vscode-fileheader" class="headerlink" title="vscode-fileheader"></a>vscode-fileheader</h2><p>添加注释到文件头，并且自动更新文件修改时间</p>
<img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/13.png" class=""> 

<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker扩展使从Visual Studio Code轻松构建，管理和部署容器化应用程序变得容易。它还提供了在容器内对Node.js，Python和.NET Core的一键式调试。</p>
<h2 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a>draw.io</h2><p>矢量图工具，可以画流程图，新建<code>.drawio</code>,<br> <img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/4.png" class=""> </p>
<h2 id="vscode-mindmap"><a href="#vscode-mindmap" class="headerlink" title="vscode-mindmap"></a>vscode-mindmap</h2><p>vs脑图插件，项目里新建一个.km 文件，然后用它打开，直接编辑脑图。<br> <img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/3.png" class=""> </p>
<h2 id="HexEditor"><a href="#HexEditor" class="headerlink" title="HexEditor"></a>HexEditor</h2><p> 二进制编辑器，可以用来编辑二进制文件，如果你需要的话，右键，打开方式,用<code>HexEditor</code>打开</p>
<h2 id="Cloudmusic"><a href="#Cloudmusic" class="headerlink" title="Cloudmusic"></a>Cloudmusic</h2><p>网易云音乐 VS Code 插件。<br> <img src="/2022/03/14/vscode%E8%AE%A9%E4%BA%BA%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E6%8F%92%E4%BB%B6/9.png" class=""> </p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli3.0+中使用CDN加载资源</title>
    <url>/2021/12/10/vue-cli3-0-%E4%B8%AD%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>在<code>vue.config.js</code>中配置使用CDN加载的modules（使用全局变量代替），比如</p>
<pre><code class="js"> chainWebpack: config =&gt; &#123;
    config.set(&#39;externals&#39;, &#123;
        &#39;vue&#39;: &#39;Vue&#39;,//&quot;库名:引入后的别名&quot; 
        &#39;vue-router&#39;: &#39;VueRouter&#39;,
        &#39;vuex&#39;: &#39;Vuex&#39;,
        &#39;mint-ui&#39;: &#39;MintUI&#39;
    &#125;)
  &#125;
</code></pre>
<p>然后在public中的<code>index.html</code>加入链接,比如上面所列的库</p>
<pre><code class="html">    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-router@3.5.3/dist/vue-router.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vuex@3.6.2/dist/vuex.min.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/mint-ui/lib/style.css&quot; /&gt;
    &lt;script src=&quot;https://unpkg.com/mint-ui/lib/index.js&quot;&gt;&lt;/script&gt; 
</code></pre>
<p> 资源要自己找，这边推荐两个CDN平台</p>
<ul>
<li><a href="https://www.jsdelivr.com/">jsdelivr</a> </li>
<li><a href="https://www.unpkg.com/">unpkg</a></li>
</ul>
<p>这样就配置完成了，改成CDN的话，有些库的使用方式需要改一下，参照每个库的官方说明即可，比如<a href="https://router.vuejs.org/zh/">Vue Router</a><br>说明了CDN和NPM安装的区别:</p>
<ul>
<li>CDN</li>
</ul>
<pre><code class="HTML">&lt;!-- 在 Vue 后面加载 vue-router，它会自动安装的： --&gt;
&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/path/to/vue-router.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>NPM</li>
</ul>
<pre><code class="bash">npm install vue-router
</code></pre>
<p>如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能：</p>
<pre><code class="js">import Vue from &#39;vue&#39;
import VueRouter from &#39;vue-router&#39;
Vue.use(VueRouter)
</code></pre>
<p>其他的不一一说明了</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli3.0+按需引入mint-ui</title>
    <url>/2021/12/10/vue-cli3-0-%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5UI/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先需要<code>babel-plugin-component</code></p>
<pre><code class="bash">npm install babel-plugin-component -D 
</code></pre>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>然后在<code>babel.config.js</code>中配置</p>
<pre><code class="bash">module.exports = &#123;
  presets: [&quot;@vue/cli-plugin-babel/preset&quot;],
  plugins: [
       [
      &quot;component&quot;,
      &#123;
        libraryName: &quot;mint-ui&quot;,
        style: true,
      &#125;
    ],
  ]
&#125;;
</code></pre>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在<code>main.js中</code>使用</p>
<pre><code class="js">import &#123; Swipe, SwipeItem &#125; from &quot;mint-ui&quot;;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack和gulp的区别</title>
    <url>/2021/12/21/webpack%E5%92%8Cgulp%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>Gulp 的定位 <strong>Task Runner</strong>, 就是用来跑一个一个任务的。</p>
<p>放在以前比如我想用sass写css, coffee写js, 我必须手动的用相应的compiler去编译各自的文件，然后各自minify。这时候designer给你了两张新图片，好嘞，接着用自己的小工具手动去压缩图片。<br>后来前端人不能忍了，搞出个自动化这个流程的 Grunt/Gulp, 比如你写完代码后要想发布production版本，用一句<code>gulp build</code>就可以</p>
<ul>
<li>rm 掉 dist文件夹中以前的旧文件</li>
<li>自动把sass编译成css, coffee编译成js</li>
<li>压缩各自的文件，压缩图片，生成图片sprite</li>
<li>拷贝minified/uglified 文件到 dist 文件夹</li>
</ul>
<p>但是它没发解决的是 js module 的问题，是你写代码时候如何组织代码结构的问题.</p>
<span id="more"></span>
<p>之前大家可以用 require.js, sea.js 来 require dependency, 后来出了一个 webpack 说 我们能不能把所有的文件(css, image, js) 都用 js 来 生成依赖，最后生成一个bundle呢？ 所以webpack 也叫做 <strong>file bundler</strong> .</p>
<p>同时 webpack 为了解决可以 require 不同文件的需求引入了loader, 比如面对sass文件有</p>
<ul>
<li><p>sass-loader, 把sass 转换成 css</p>
</li>
<li><p>css-loader, 让 webpack 能识别处理 css</p>
</li>
<li><p>style-loader, 把识别后的 css 插入到 html style中<br>类似的识别es6 有babel-loader</p>
</li>
</ul>
<p>本来这就是 webpack 的初衷，require everything, bundle everything. 一开始 webpack 刚出来的时候大家都是把它结合着 gulp 一起用的， gulp 里面有个 gulp-webpack，就是让 webpack 专门去做module dependency的事情, 生成一个bundle.js文件，然后再用 gulp 去做一些其他杂七杂八minify, uglify的事情。 后来人们发现 webpack 有个plugins的选项， 可以用来进一步处理经过loader 生成的bundle.js，于是有人写了对应的插件， 所以minify/uglify, 生成hash的工作也可以转移到webpack本身了，挤掉了gulp这部分的市场份额。 再后来大家有发现 npm/package.json 里面的scripts 原来好好用啊，调用任务的时候就直接写一个简单的命令，因为 gulp 也不就是各种插件命令的组合呀，大部分情况下越来越不需要 gulp/grunt 之类的了 ref. 所以你现在看到的很多新项目都是package.json里面scripts 写了一堆，外部只需要一个webpack就够了。</p>
<p>转自<a href="https://segmentfault.com/q/1010000008058766">drbelfast在segmentfault的部分回答</a>，侵删</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>前端github库star推荐</title>
    <url>/2022/02/11/%E5%89%8D%E7%AB%AFgithub%E5%BA%93star%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h2 id="JavaScript数据结构和算法完全解析-javascript-algorithms"><a href="#JavaScript数据结构和算法完全解析-javascript-algorithms" class="headerlink" title="JavaScript数据结构和算法完全解析 javascript-algorithms"></a>JavaScript数据结构和算法完全解析 <a href="https://github.com/trekhleb/javascript-algorithms">javascript-algorithms</a></h2><p><code>stars：134k+</code><br>几乎涵盖了常用数据结构和算法的解析和JavaScript实现，慢慢肝吧。</p>
<p>每种算法和数据结构都有自己的 README，包含相关说明和链接，以便进一步学习 (还有 YouTube 视频) 。</p>
<h2 id="30秒代码-30-seconds-of-code"><a href="#30秒代码-30-seconds-of-code" class="headerlink" title="30秒代码 30-seconds-of-code"></a>30秒代码 <a href="https://github.com/30-seconds/30-seconds-of-code">30-seconds-of-code</a></h2><p><code>stars：91.8k+</code><br>满足您所有开发需求的简短 JavaScript 代码片段，适合平时琐碎时间学习，将前端的相关知识划分为小知识点，并且附有代码片段</p>
<h2 id="JavaScript-样式指南-airbnb-js-style-guide"><a href="#JavaScript-样式指南-airbnb-js-style-guide" class="headerlink" title="JavaScript 样式指南 airbnb-js-style-guide"></a>JavaScript 样式指南 <a href="https://github.com/airbnb/javascript">airbnb-js-style-guide</a></h2><p><code>stars：119k+</code><br>太经典了，无论你是初级中级，还是高级工程师，平时多看看规范是进步最快的方式。</p>
<h2 id="你不知道的JavaScriptYou-Dont-Know-JS"><a href="#你不知道的JavaScriptYou-Dont-Know-JS" class="headerlink" title="你不知道的JavaScriptYou-Dont-Know-JS"></a>你不知道的JavaScript<a href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a></h2><p><code>stars：149k+</code></p>
<p>这是深入探讨 JavaScript 语言核心机制的书籍，这是第二版。系统性的学习JavaScript，这个仓库是最高不过了。</p>
<h2 id="什么是-的JavaScriptwtfjs"><a href="#什么是-的JavaScriptwtfjs" class="headerlink" title="什么是**的JavaScriptwtfjs"></a>什么是**的JavaScript<a href="https://github.com/denysdovhan/wtfjs">wtfjs</a></h2><p><code>stars：25.2k+</code></p>
<p>一个有趣的JavaScript学习仓库，快乐学习每一天。just for fun。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>在vs内调试js</title>
    <url>/2022/03/14/%E5%9C%A8vs%E5%86%85%E8%B0%83%E8%AF%95js/</url>
    <content><![CDATA[<p>在工作区中，找到调试面板，点击创建<code>launch.json</code></p>
<img src="/2022/03/14/%E5%9C%A8vs%E5%86%85%E8%B0%83%E8%AF%95js/0.png" class=""> 
<p>或点击上方的展开箭头，添加配置</p>
<img src="/2022/03/14/%E5%9C%A8vs%E5%86%85%E8%B0%83%E8%AF%95js/1.png" class=""> 
<p>环境选择nodejs</p>
<img src="/2022/03/14/%E5%9C%A8vs%E5%86%85%E8%B0%83%E8%AF%95js/4.png" class=""> 
<p>打开如下json文件</p>
<img src="/2022/03/14/%E5%9C%A8vs%E5%86%85%E8%B0%83%E8%AF%95js/2.png" class=""> 
<p>一般不用做什么修改，保存该json后，文件面板出现</p>
<img src="/2022/03/14/%E5%9C%A8vs%E5%86%85%E8%B0%83%E8%AF%95js/3.png" class=""> 
<p>然后就可以开始调试了，打好断点，点击上方运行</p>
<img src="/2022/03/14/%E5%9C%A8vs%E5%86%85%E8%B0%83%E8%AF%95js/5.png" class=""> 





]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>10分钟搭建个人静态博客网站</title>
    <url>/2021/11/30/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>  只看步骤的话，跳到快速开始</p>
<img src="/2021/11/30/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/banner.jpg" class=""> 

<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>静态网站非常适合专注于内容的网站，比如像博客网站，这边记录一下我搭建这个静态博客的步骤，首先选择服务器，虽然现在云服务器很方便，但如果只是做个静态网站的话，有个更方便的方法是用<a href="https://pages.github.com/">Github Pages</a>，将资源部署在github上，并且还会有自己的域名，省时省力。<span id="more"></span>然后网站资源也可以用一些静态博客生成框架去做，一些流行的框架有：</p>
<ul>
<li><a href="http://jekyllrb.com/">Jekyll</a>，Github Pages官方推荐的构建框架，在Windows上使用的话需要先安装Ruby的运行环境，如果你熟悉Ruby的话试试看，具体参见官方文档</li>
<li><a href="https://hexo.io/zh-cn/">Hexo</a>，这个博客站就是用Hexo生成的，Hexo运行需要Node.js环境，前端开发人员可以选择这个，个人觉得比Jekyll更容易些。</li>
<li><a href="https://www.gohugo.org/">Hugo</a>，官方自我介绍：Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。</li>
<li><a href="http://octopress.org/">Octopress</a>,基于Jekyll框架，官方介绍：A blogging framework for hackers.</li>
<li><a href="https://docs.getpelican.com/en/latest/index.html">Pelican</a>,Python编写的框架。</li>
<li><a href="https://middlemanapp.com/">MiddleMan</a>，Ruby编写的框架，官方介绍：Middleman is a static site generator using all the shortcuts and tools in modern web development.</li>
<li><a href="https://www.metalsmith.io/">Metalsmith</a>，官方介绍：An extremely simple, pluggable static site generator.</li>
</ul>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>本教程基于GitHub Pages和Hexo,在windows上操作，</p>
<h3 id="一、github账号"><a href="#一、github账号" class="headerlink" title="一、github账号"></a>一、github账号</h3><p>你要先有个<a href="https://github.com/%E8%B4%A6%E5%8F%B7">GitHub</a>账号，注册登录后，新建一个repository，不了解github的话在左上角加号图标</p>
<img src="/2021/11/30/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/1.png" class="">
<br> 

<p>这边的Repository name要按照一定格式</p>
<pre><code class="js">//usernam为你的用户名称
username.github.io 
</code></pre>
<p>比如我的用户名是wufan123，那么就是</p>
<pre><code class="JavaScript">wufan123.github.io
</code></pre>
<p>创建完成后先把当前页面放着，它大概长这样子</p>
<img src="/2021/11/30/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/2.png" class="">
<br>

<p>我这边新建了一个static做示范，你的应该是</p>
<pre><code class="js">username/username.github.io
</code></pre>
<h3 id="二、安装git"><a href="#二、安装git" class="headerlink" title="二、安装git"></a>二、安装git</h3><p>接着我们需要安装下<a href="https://git-scm.com/downloads">git</a>,选择windows，然后根据你的电脑选择32位或者64位，下载然后一路下一步安装完成。安装好之后，右键鼠标菜单应该可以看到<br>“Git Bash Here”菜单。安装git就完成了</p>
<h3 id="三、安装Node-js"><a href="#三、安装Node-js" class="headerlink" title="三、安装Node.js"></a>三、安装Node.js</h3><p>接着安装<a href="https://nodejs.org/en/">Node.js</a>环境,选择LTS版本，下一步，安装完成之后通过鼠标右键菜单选择Git Bash Here，输入</p>
<pre><code class="bash">node -v 
</code></pre>
<p>显示Node.js版本，安装成功</p>
<h3 id="四、安装Hexo"><a href="#四、安装Hexo" class="headerlink" title="四、安装Hexo"></a>四、安装Hexo</h3><p>可以先设置下npm的淘宝镜像，这样安装比较快</p>
<pre><code class="bash">npm config set registry https://registry.npm.taobao.org
</code></pre>
<p>然后在Git Bash中输入</p>
<pre><code class="bash">npm install -g hexo-cli 
</code></pre>
<p>输入</p>
<pre><code class="bash">hexo -v
</code></pre>
<p>显示版本信息安装成功</p>
<h3 id="五、建站"><a href="#五、建站" class="headerlink" title="五、建站"></a>五、建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<pre><code class="bash">hexo init my-blog
cd my-blog
npm install
</code></pre>
<p>我新建了一个my-blog的hexo站点项目，它的目录是这样子的</p>
<pre><code class="bash">.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre>
<p>我们找到_config.yml文件，修改配置</p>
<pre><code class="bash">deploy:
  type: git
  repo: &lt;repository url&gt; #git@github.com:wufan123/wufan123.github.io.git
  branch: gh-pages
</code></pre>
<p>将repo改成刚才在Github新建的repo地址。</p>
<h3 id="六、添加git-ssh"><a href="#六、添加git-ssh" class="headerlink" title="六、添加git ssh"></a>六、添加git ssh</h3><p>为了能顺利将刚才生成的资源部署到github上（公钥认证），我们先创建一对公钥密匙</p>
<pre><code class="bash">$ ssh-keygen -o
</code></pre>
<p>然后输入</p>
<pre><code class="bash">$ cat ~/.ssh/id_rsa.pub
</code></pre>
<p>会出现类似这样的字符串</p>
<pre><code class="bash">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
NrRFi9wrf+M7Q== schacon@mylaptop.local
</code></pre>
<p>上面的是示例，请拷贝自己的，然后添加到<a href="https://github.com/settings/keys">Github SSH keys</a>中，点击界面中的New SSH key，title是自己给它的名字，key中黏贴刚才拷贝的那一串公匙内容。</p>
<h3 id="七、部署"><a href="#七、部署" class="headerlink" title="七、部署"></a>七、部署</h3><p>现在你可以运行</p>
<pre><code class="bash">hexo deploy
</code></pre>
<p>进行部署了，顺利的话，你可以看到你Github上username.github.io中会多出一个<code>gh-pages</code>分支，过一小会，你就可以在浏览器中输入username.github.io访问自己的博客网站了比如我的地址就是<a href="https://wufan123.github.io/">wufan123.github.io</a>,如果你完全按照我的步骤来的话，它差不多长这样子的：</p>
<img src="/2021/11/30/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/3.png" class="">
<br>
恭喜你建站成功了！

<h3 id="八、写作"><a href="#八、写作" class="headerlink" title="八、写作"></a>八、写作</h3><p>可以通过下列命令来创建一篇新文章或者新的页面</p>
<pre><code class="bash">$ hexo new [layout] &lt;title&gt;
</code></pre>
<p>layout不是必须参数，默认为post，比如创建一篇搭建个人博客网站</p>
<pre><code class="bash">hexo new 搭建个人博客网站
</code></pre>
<p>你在source中可以看到生成了一个<code>搭建个人博客网站.md</code>文件，然后就是用你熟悉的md语法写作了，写完之后，可以用运行下列命令启动一个本地服务器预览一下</p>
<pre><code class="bash">hexo server
</code></pre>
<p>觉得没问题的话，就可以重新部署到gitub.io了，部署命令</p>
<pre><code class="bash">hexo clean 
hexo deploy
</code></pre>
<p>稍等一下就可以看到博客站更新了,其他关于写作，网站配置可以移步<a href="https://hexo.io/zh-cn/docs">官方文档说明</a></p>
<h3 id="八、主题"><a href="#八、主题" class="headerlink" title="八、主题"></a>八、主题</h3><p>如果你觉得官方的默认主题不好看，可以换主题，官方的<a href="https://hexo.io/themes/">主题列表</a>有300+不同的主题，应该会有一款符合你的审美</p>
<img src="/2021/11/30/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/4.png" class="">
<br>

<p>当然你有前端开发或其他编程经验的话也可以在别人的主题上做一些改动或者自定义一款自己的主题，后面还能贡献到官方的主题列表。这边我推荐几个我觉得挺好看的主题：</p>
<ul>
<li><a href="https://github.com/Haojen/hexo-theme-Claudia">hexo-theme-Claudia</a></li>
<li><a href="https://github.com/blleng/hexo-theme-lx">hexo-theme-lx</a></li>
<li><a href="https://github.com/blleng/hexo-theme-lx">hexo-theme-tranquilpeak</a></li>
<li><a href="https://github.com/probberechts/hexo-theme-cactus">hexo-theme-cactus</a></li>
<li><a href="https://github.com/probberechts/hexo-theme-cactus">hexo-theme-cactus</a></li>
<li><a href="https://github.com/79E/hexo-theme-quiet">hexo-theme-quiet</a></li>
</ul>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>最后稍微说明一下，如果你遇到困难可以有点思路，<code>Github Pages</code>是给你用来放静态资源的一个地方，你不弄博客网站，也可以直接放一个<code>.md</code>文件、图片、视频或者<code>.html</code>都可以通过<code>username.github.io</code>访问到。git是一个分布式的版本管理工具，不了解的话，可以简单理解成是将你本地的文件更新到你github。hexo是用来构建静态博客的框架，你不用框架可不可以弄静态博客，可以，但相对费力费时，用hexo会更方便，它有很多现成的东西，你只要专注于写作就可以了，如果文章中有什么问题或者什么问题可以留言也可以给我发邮件。瑞思拜~</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>GitHub-Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>解决移动端border 1px 问题</title>
    <url>/2022/03/22/%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E7%AB%AFborder%201px%20%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>由于某些机型分辨率过高,会导致1px变成2+px的问题,样式解决的话，通过媒体选择器和<code>transform</code>方式,参考代码如下</p>
<pre><code class="css">.list li:after&#123;
  content:&#39;&#39;;
  float:left;
  width:100%;
  border-bottom: #eeeeee solid 1px;
  height:1px;
&#125;
@media only screen and (-webkit-min-device-pixel-ratio: 2.0),
only screen and (min--moz-device-pixel-ratio: 2.0),
only screen and (-o-min-device-pixel-ratio: 200/100),
only screen and (min-device-pixel-ratio: 2.0) &#123;
  .list li:after&#123;
    -webkit-transform: scaleY(0.5);
    transform: scaleY(0.5);
  &#125;
&#125;
@media only screen and (-webkit-min-device-pixel-ratio: 2.5),
only screen and (min--moz-device-pixel-ratio: 2.5),
only screen and (-o-min-device-pixel-ratio: 250/100),
only screen and (min-device-pixel-ratio: 2.5) &#123;
  .list li:after&#123;
    -webkit-transform: scaleY(0.33333334);
    transform: scaleY(0.33333334);
  &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli5源码学习</title>
    <url>/2021/12/21/vue-cli5%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="vue-js"><a href="#vue-js" class="headerlink" title="vue.js"></a>vue.js</h2><p>首先查看<code>packages/@vue/cli/bin/vue.js</code>文件</p>
<span id="more"></span>

<pre><code class="javascript">/* @vue/cli-shared-utils集成了一些通用工具，比如chalk(终端字符串样式)，
semver(检查npm包版本)，也封装了一些常用方法，像退出程序，合法判断等 */
const &#123; chalk, semver &#125; = require(&quot;@vue/cli-shared-utils&quot;);
const requiredVersion = require(&quot;../package.json&quot;).engines.node;

/* 用Levenshtein distance算法来计算两个字符的差异，这个算法我也没去了解，
这边在后面用来比较错误命令与现有命令，给出建议 */
const leven = require(&quot;leven&quot;);

function checkNodeVersion(wanted, id) &#123;
  if (!semver.satisfies(process.version, wanted, &#123; includePrerelease: true &#125;)) &#123;
    console.log(
      chalk.red(
        &quot;You are using Node &quot; +
          process.version +
          &quot;, but this version of &quot; +
          id +
          &quot; requires Node &quot; +
          wanted +
          &quot;.\nPlease upgrade your Node version.&quot;
      )
    );
    process.exit(1);
  &#125;
&#125;

//检查npm版本
checkNodeVersion(requiredVersion, &quot;@vue/cli&quot;);

const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
//将 Windows 反斜杠路径转换为斜杠路径：foo\\bar➔foo/bar
const slash = require(&quot;slash&quot;);
//解析参数选项
const minimist = require(&quot;minimist&quot;);
// enter debug mode when creating test repo
if (
  slash(process.cwd()).indexOf(&quot;/packages/test&quot;) &gt; 0 &amp;&amp;
  (fs.existsSync(path.resolve(process.cwd(), &quot;../@vue&quot;)) ||
    fs.existsSync(path.resolve(process.cwd(), &quot;../../@vue&quot;)))
) &#123;
  process.env.VUE_CLI_DEBUG = true;
&#125;

//commander是nodejs命令行的解决方案
const program = require(&quot;commander&quot;);
const loadCommand = require(&quot;../lib/util/loadCommand&quot;);
/*
.
.
. 
关注下create命令，其他命令先略过
*/
program
  .command(&#39;create &lt;app-name&gt;&#39;)
  .description(&#39;create a new project powered by vue-cli-service&#39;)
  .option(&#39;-p, --preset &lt;presetName&gt;&#39;, &#39;Skip prompts and use saved or remote preset&#39;)
  .option(&#39;-d, --default&#39;, &#39;Skip prompts and use default preset&#39;)
  .option(&#39;-i, --inlinePreset &lt;json&gt;&#39;, &#39;Skip prompts and use inline JSON string as preset&#39;)
  .option(&#39;-m, --packageManager &lt;command&gt;&#39;, &#39;Use specified npm client when installing dependencies&#39;)
  .option(&#39;-r, --registry &lt;url&gt;&#39;, &#39;Use specified npm registry when installing dependencies (only for npm)&#39;)
  .option(&#39;-g, --git [message]&#39;, &#39;Force git initialization with initial commit message&#39;)
  .option(&#39;-n, --no-git&#39;, &#39;Skip git initialization&#39;)
  .option(&#39;-f, --force&#39;, &#39;Overwrite target directory if it exists&#39;)
  .option(&#39;--merge&#39;, &#39;Merge target directory if it exists&#39;)
  .option(&#39;-c, --clone&#39;, &#39;Use git clone when fetching remote preset&#39;)
  .option(&#39;-x, --proxy &lt;proxyUrl&gt;&#39;, &#39;Use specified proxy when creating project&#39;)
  .option(&#39;-b, --bare&#39;, &#39;Scaffold project without beginner instructions&#39;)
  .option(&#39;--skipGetStarted&#39;, &#39;Skip displaying &quot;Get started&quot; instructions&#39;)
  .action((name, options) =&gt; &#123;
    if (minimist(process.argv.slice(3))._.length &gt; 1) &#123;
      console.log(chalk.yellow(&#39;\n Info: You provided more than one argument. The first one will be used as the app\&#39;s name, the rest are ignored.&#39;))
    &#125;
    // --git makes commander to default git to true
    if (process.argv.includes(&#39;-g&#39;) || process.argv.includes(&#39;--git&#39;)) &#123;
      options.forceGit = true
    &#125;
    //引入lib中的create
    require(&#39;../lib/create&#39;)(name, options)
  &#125;)
</code></pre>
<!-- more -->

<h2 id="create-js"><a href="#create-js" class="headerlink" title="create.js"></a>create.js</h2><p>然后我们去看<code>packages/@vue/cli/lib/create.js</code></p>
<pre><code class="javascript">//fs-extra包含了fs没有提供的方法，并支持promise
const fs = require(&#39;fs-extra&#39;)
const path = require(&#39;path&#39;)
//inquirer  提供命令行用户交互
const inquirer = require(&#39;inquirer&#39;)
const Creator = require(&#39;./Creator&#39;)
const &#123; clearConsole &#125; = require(&#39;./util/clearConsole&#39;)
//提示可配置的modules
const &#123; getPromptModules &#125; = require(&#39;./util/createTools&#39;)
//stopSpinner封装了ora(一个终端的加载提示)
const &#123; chalk, error, stopSpinner, exit &#125; = require(&#39;@vue/cli-shared-utils&#39;)
//验证项目名称合法
const validateProjectName = require(&#39;validate-npm-package-name&#39;)

async function create (projectName, options) &#123;
  if (options.proxy) &#123;
    process.env.HTTP_PROXY = options.proxy
  &#125;
  //process.cwd() 当前工作目录
  const cwd = options.cwd || process.cwd()
  const inCurrent = projectName === &#39;.&#39;
  // path.relative() 算出当前文件夹名
  const name = inCurrent ? path.relative(&#39;../&#39;, cwd) : projectName
  // 目标文件夹的绝对路径
  const targetDir = path.resolve(cwd, projectName || &#39;.&#39;)
  // 验证工程名是否合法，返回&#123; validForNewPackages: true, validForOldPackages: true &#125;
  const result = validateProjectName(name)
  if (!result.validForNewPackages) &#123;
    console.error(chalk.red(`Invalid project name: &quot;$&#123;name&#125;&quot;`))
    result.errors &amp;&amp; result.errors.forEach(err =&gt; &#123;
      console.error(chalk.red.dim(&#39;Error: &#39; + err))
    &#125;)
    result.warnings &amp;&amp; result.warnings.forEach(warn =&gt; &#123;
      console.error(chalk.red.dim(&#39;Warning: &#39; + warn))
    &#125;)
    exit(1)
  &#125;
  //目标文件夹已存在的一些处理
  if (fs.existsSync(targetDir) &amp;&amp; !options.merge) &#123;
    if (options.force) &#123;
      await fs.remove(targetDir)
    &#125; else &#123;
      await clearConsole()
      if (inCurrent) &#123;
        const &#123; ok &#125; = await inquirer.prompt([
          &#123;
            name: &#39;ok&#39;,
            type: &#39;confirm&#39;,
            message: `Generate project in current directory?`
          &#125;
        ])
        if (!ok) &#123;
          return
        &#125;
      &#125; else &#123;
        const &#123; action &#125; = await inquirer.prompt([
          &#123;
            name: &#39;action&#39;,
            type: &#39;list&#39;,
            message: `Target directory $&#123;chalk.cyan(targetDir)&#125; already exists. Pick an action:`,
            choices: [
              &#123; name: &#39;Overwrite&#39;, value: &#39;overwrite&#39; &#125;,
              &#123; name: &#39;Merge&#39;, value: &#39;merge&#39; &#125;,
              &#123; name: &#39;Cancel&#39;, value: false &#125;
            ]
          &#125;
        ])
        if (!action) &#123;
          return
        &#125; else if (action === &#39;overwrite&#39;) &#123;
          console.log(`\nRemoving $&#123;chalk.cyan(targetDir)&#125;...`)
          await fs.remove(targetDir)
        &#125;
      &#125;
    &#125;
  &#125;

  //具体工作交给创造器
  const creator = new Creator(name, targetDir, getPromptModules())
  await creator.create(options)
&#125;

module.exports = (...args) =&gt; &#123;
  return create(...args).catch(err =&gt; &#123;
    stopSpinner(false) // do not persist
    error(err)
    if (!process.env.VUE_CLI_TEST) &#123;
      process.exit(1)
    &#125;
  &#125;)
&#125;
</code></pre>
<p>然后我们去看<code>packages/@vue/cli/lib/creator.js</code></p>
<pre><code class="js">const path = require(&#39;path&#39;)
//debug一个小型调试器
const debug = require(&#39;debug&#39;)
//上面说过的  inquirer提供命令行用户交互
const inquirer = require(&#39;inquirer&#39;)
//events 事件触发器，下面主要基于事件触发和响应的
const EventEmitter = require(&#39;events&#39;)
const Generator = require(&#39;./Generator&#39;)
//lodash提供一些常用工具方法，像深复制，防抖什么的
const cloneDeep = require(&#39;lodash.clonedeep&#39;)
//sortObject 排序对象属性，默认unicode，或者按照指定顺序来排序,这边用来排序plugin
const sortObject = require(&#39;./util/sortObject&#39;)
//getVersions 用来获取最新的cli plugin版本,大致实现,比较缓存时间,如果超过一天就去下载远程package,保证获取较新版本
const getVersions = require(&#39;./util/getVersions&#39;)
//PackageManager 包的管理更新
const PackageManager = require(&#39;./util/ProjectPackageManager&#39;)
//clearConsole 生成一个标题再通过换行清空cli输出
const &#123; clearConsole &#125; = require(&#39;./util/clearConsole&#39;)
const PromptModuleAPI = require(&#39;./PromptModuleAPI&#39;)
const writeFileTree = require(&#39;./util/writeFileTree&#39;)
const &#123; formatFeatures &#125; = require(&#39;./util/features&#39;)
const loadLocalPreset = require(&#39;./util/loadLocalPreset&#39;)
const loadRemotePreset = require(&#39;./util/loadRemotePreset&#39;)
const generateReadme = require(&#39;./util/generateReadme&#39;)
const &#123; resolvePkg, isOfficialPlugin &#125; = require(&#39;@vue/cli-shared-utils&#39;)
/*  
...省略部分
*/
module.exports = class Creator extends EventEmitter &#123;
   //...
  async create (cliOptions = &#123;&#125;, preset = null) &#123;
    //待学习...
  &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>cli</tag>
      </tags>
  </entry>
  <entry>
    <title>svg路径动画</title>
    <url>/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在日常工作中遇到这样的任务</p>
 <img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/1.jpg" class="" width="500"> 
<p>  通过svp可以相对比较方便的把路径画出来，参考代码</p>
<pre><code class="SVG">//通过viewBox做适配
&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;7.5rem&quot;
           height=&quot;6.35rem&quot; id=&quot;map&quot; viewBox=&quot;0,0,750,635&quot;&gt;
           &lt;line x1=&quot;318&quot; y1=&quot;148&quot; x2=&quot;478&quot; y2=&quot;178&quot; style=&quot;stroke:#ffffff;stroke-width:3&quot;&gt;&lt;/line&gt;
           &lt;line x1=&quot;478&quot; y1=&quot;178&quot; x2=&quot;581&quot; y2=&quot;264&quot; style=&quot;stroke:#ffffff;stroke-width:3&quot;&gt;&lt;/line&gt;
           &lt;line x1=&quot;581&quot; y1=&quot;264&quot; x2=&quot;690&quot; y2=&quot;376&quot; style=&quot;stroke:#ffffff;stroke-width:3&quot;&gt;&lt;/line&gt;
           &lt;line x1=&quot;690&quot; y1=&quot;376&quot; x2=&quot;590&quot; y2=&quot;485&quot; style=&quot;stroke:#ffffff;stroke-width:3&quot;&gt;&lt;/line&gt;
           &lt;line x1=&quot;590&quot; y1=&quot;485&quot; x2=&quot;447&quot; y2=&quot;581&quot; style=&quot;stroke:#ffffff;stroke-width:3&quot;&gt;&lt;/line&gt;
           &lt;line x1=&quot;447&quot; y1=&quot;581&quot; x2=&quot;260&quot; y2=&quot;518&quot; style=&quot;stroke:#ffffff;stroke-width:3&quot;&gt;&lt;/line&gt;
           &lt;line x1=&quot;260&quot; y1=&quot;518&quot; x2=&quot;94&quot; y2=&quot;429&quot; style=&quot;stroke:#ffffff;stroke-width:3&quot;&gt;&lt;/line&gt;
           &lt;line x1=&quot;94&quot; y1=&quot;429&quot; x2=&quot;63&quot; y2=&quot;313&quot; style=&quot;stroke:#ffffff;stroke-width:3&quot;&gt;&lt;/line&gt;
           &lt;line x1=&quot;63&quot; y1=&quot;313&quot; x2=&quot;127&quot; y2=&quot;197&quot; style=&quot;stroke:#ffffff;stroke-width:3&quot;&gt;&lt;/line&gt;
           &lt;line x1=&quot;127&quot; y1=&quot;197&quot; x2=&quot;191&quot; y2=&quot;206&quot; style=&quot;stroke:#ffffff;stroke-width:3&quot;&gt;&lt;/line&gt;
           &lt;line x1=&quot;191&quot; y1=&quot;206&quot; x2=&quot;318&quot; y2=&quot;148&quot; style=&quot;stroke:#ffffff;stroke-width:3&quot;&gt;&lt;/line&gt;
           &lt;circle cx=&quot;318&quot; cy=&quot;148&quot; r=&quot;10&quot; fill=&quot;#ffffff&quot; stroke=&quot;#fff&quot; stroke-width=&quot;1&quot;&gt;&lt;/circle&gt;
           &lt;circle cx=&quot;478&quot; cy=&quot;178&quot; r=&quot;10&quot; fill=&quot;#ffffff&quot; stroke=&quot;#fff&quot; stroke-width=&quot;1&quot;&gt;&lt;/circle&gt;
           &lt;circle cx=&quot;581&quot; cy=&quot;264&quot; r=&quot;10&quot; fill=&quot;#ffffff&quot; stroke=&quot;#fff&quot; stroke-width=&quot;1&quot;&gt;&lt;/circle&gt;
           &lt;circle cx=&quot;690&quot; cy=&quot;376&quot; r=&quot;10&quot; fill=&quot;#ffffff&quot; stroke=&quot;#fff&quot; stroke-width=&quot;1&quot;&gt;&lt;/circle&gt;
           &lt;circle cx=&quot;590&quot; cy=&quot;485&quot; r=&quot;10&quot; fill=&quot;#ffffff&quot; stroke=&quot;#fff&quot; stroke-width=&quot;1&quot;&gt;&lt;/circle&gt;
           &lt;circle cx=&quot;447&quot; cy=&quot;581&quot; r=&quot;10&quot; fill=&quot;#ffffff&quot; stroke=&quot;#fff&quot; stroke-width=&quot;1&quot;&gt;&lt;/circle&gt;
           &lt;circle cx=&quot;260&quot; cy=&quot;518&quot; r=&quot;10&quot; fill=&quot;#ffffff&quot; stroke=&quot;#fff&quot; stroke-width=&quot;1&quot;&gt;&lt;/circle&gt;
           &lt;circle cx=&quot;94&quot; cy=&quot;429&quot; r=&quot;10&quot; fill=&quot;#ffffff&quot; stroke=&quot;#fff&quot; stroke-width=&quot;1&quot;&gt;&lt;/circle&gt;
           &lt;circle cx=&quot;63&quot; cy=&quot;313&quot; r=&quot;10&quot; fill=&quot;#ffffff&quot; stroke=&quot;#fff&quot; stroke-width=&quot;1&quot;&gt;&lt;/circle&gt;
           &lt;circle cx=&quot;127&quot; cy=&quot;197&quot; r=&quot;10&quot; fill=&quot;#ffffff&quot; stroke=&quot;#fff&quot; stroke-width=&quot;1&quot;&gt;&lt;/circle&gt;
       &lt;/svg&gt;
</code></pre>
<p> 因为只讲svg相关的，精简一些其他元素</p>
  <img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/2.png" class=""> 

<h2 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h2><p>  这边想让它按照路径线路运动起来，我一开始通过<code>js</code>设置运动元素的top和left，效果用<code>transition</code>来实现,参考代码</p>
<pre><code class="javascript">      //收集点坐标
      var pointArr = [&#123; x: &quot;3.18rem&quot;, y: &quot;1.48rem&quot; &#125;,
      &#123; x: &quot;4.78rem&quot;, y: &quot;1.78rem&quot;, next: true &#125;,
      &#123; x: &quot;5.81rem&quot;, y: &quot;2.64rem&quot;, next: true &#125;,
      &#123; x: &quot;6.90rem&quot;, y: &quot;3.76rem&quot;, next: true &#125;,
      &#123; x: &quot;5.90rem&quot;, y: &quot;4.85rem&quot;, next: true &#125;,
      &#123; x: &quot;4.47rem&quot;, y: &quot;5.81rem&quot; &#125;,
      &#123; x: &quot;2.60rem&quot;, y: &quot;5.18rem&quot;, next: true &#125;,
      &#123; x: &quot;0.94rem&quot;, y: &quot;4.29rem&quot;, next: true &#125;,
      &#123; x: &quot;0.63rem&quot;, y: &quot;3.13rem&quot;, next: true &#125;,
      &#123; x: &quot;1.27rem&quot;, y: &quot;1.97rem&quot;, next: true &#125;,
      &#123; x: &quot;1.91rem&quot;, y: &quot;2.06rem&quot;, next: true &#125;,
          // &#123; x: &quot;3.18rem&quot;, y: &quot;1.48rem&quot;&#125;
      ];
      //移动方法，参数一为需要移动的选择器，参数二为移动点，参数3是移动时间
      function moveNext(selector,points,duration)&#123;
          var el = $(selector);
          if(!el.length)&#123;
              throw new Error(&quot;selector: &#39;&quot;+selector+&quot;&#39; no find!&quot;)
          &#125;;
          if(!points.length)return;
          if(!points.index&amp;&amp;points.index!=0)&#123; 
              points.index =0;
          &#125;
          points.index = ++points.index%points.length
          var p = points[points.index]
          el.css(&quot;pointer-events&quot;,&quot;none&quot;);
          el.css(&quot;transition&quot;,&quot;all linear &quot;+duration+&quot;ms&quot;)
          el.css(&quot;left&quot;, p.x).css(&quot;top&quot;, p.y);
          setTimeout(function()&#123;
              el.css(&quot;pointer-events&quot;,&quot;initial&quot;);
              el.css(&quot;transition&quot;,&quot;none&quot;)
              if(p.next)&#123;
                  moveNext(selector,pointArr,duration)
              &#125;
          &#125;, duration);
      &#125;
      //绑定点击事件
      $(&quot;.mapbox .imgbox&quot;).click(function () &#123;
          moveNext(&quot;.mapbox .imgbox&quot;,pointArr,600);
      &#125;)
</code></pre>
<p>得到的效果如图</p>
  <img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/3.gif" class=""> 

<p>做到这边就想到之前做过的路径图</p>
  <img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/4.jpg" class="" width="500"> 

<h2 id="Path命令"><a href="#Path命令" class="headerlink" title="Path命令"></a>Path命令</h2><p>它这边的是曲线路径，当时简单切图，现在如果要能沿路径运动的话，要改造一番，所以是画曲线，刚才直线很好画，参数也好理解，两点成线，现在用svg画曲线，第一个先了解<code>path</code> ,我们可以用<code>path</code>画出复杂的图形，当然也包括曲线，它包含下面的命令</p>
<ul>
<li>M = moveto</li>
<li>L = lineto</li>
<li>H = horizontal lineto</li>
<li>V = vertical lineto</li>
<li>C = curveto</li>
<li>S = smooth curveto</li>
<li>Q = quadratic Bézier curve</li>
<li>T = smooth quadratic Bézier curveto</li>
<li>A = elliptical Arc</li>
<li>Z = closepath</li>
</ul>
<p>比如</p>
<pre><code>&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;
    &lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt;
&lt;/svg&gt;
</code></pre>
<p>可以画出一个三角形</p>
  <img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/5.jpg" class=""> 

<p>画曲线主要用到</p>
<ul>
<li>C = curveto</li>
<li>S = smooth curveto</li>
<li>Q = quadratic Bézier curve</li>
<li>T = smooth quadratic Bézier curveto<br>这几个命令，C是三阶贝塞尔曲线，Q是二阶贝塞尔曲线，所以如果贝塞尔曲线不了解的话，这边简单介绍一下</li>
</ul>
<h2 id="贝塞尔曲线（Bezier-curve）"><a href="#贝塞尔曲线（Bezier-curve）" class="headerlink" title="贝塞尔曲线（Bézier curve）"></a>贝塞尔曲线（Bézier curve）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>组成：由起点、终点、控制点组成。</p>
<p>说明：其中控制点的个数可以是0-n, 0个控制点的时候为一阶贝塞尔曲线（一条直线），1个控制点的时候为二阶贝塞尔曲线，以此类推。</p>
<p>重要性：是计算机图形学中相当重要的参数曲线。</p>
<p>前身：伯恩斯坦多项式，德卡斯特里奥算法</p>
<p>由来：由法国工程师（数学家）皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。</p>
<p>出发点：只需要很少的控制点，就可以绘制出一条平滑复杂的曲线。</p>
<h3 id="数学知识-二阶贝塞尔曲线为例"><a href="#数学知识-二阶贝塞尔曲线为例" class="headerlink" title="数学知识(二阶贝塞尔曲线为例)"></a>数学知识(二阶贝塞尔曲线为例)</h3><ul>
<li><p>步骤一：在平面内选3个不同线的点并且依次用线段连接</p>
 <img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/6.webp" class="" width="300"> </li>
<li><p>步骤二：在AB和BC线段上找出点D和点E，使得 AD/AB = BE/BC</p>
 <img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/7.webp" class="" width="300"> </li>
<li><p>步骤三：连接DE，在DE上寻找点F，F点需要满足：DF/DE = AD/AB = BE/BC</p>
<img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/8.webp" class="" width="300"> </li>
<li><p>步骤四：DF/DE = AD/AB = BE/BC = t<br>当 t 从 0-1 变化时，逆推出的所有 F 点连接起来，就绘制出了一条曲线</p>
<img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/9.gif" class="" width="300"> </li>
<li><p>公式推导</p>
<ul>
<li><p>P点为已知点，B点为最终所求的点(上面图所示的F点)。</p>
</li>
<li><p>一阶贝塞尔：B(t) = P0(1-t) + p1t</p>
</li>
<li><p>二阶贝塞尔：B(t) = P0(1-t)² + 2P1t(1-t) + P2t²</p>
</li>
<li><p>三阶贝塞尔：B(t) = P0(1-t)³ + 3P1t(1-t)² + 3P2t²(1-t) + P3t³</p>
</li>
<li><p>n阶贝塞尔 <img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/10.jpg" class=""> </p>
</li>
</ul>
</li>
</ul>
<h3 id="曲线绘制过程"><a href="#曲线绘制过程" class="headerlink" title="曲线绘制过程"></a>曲线绘制过程</h3><ul>
<li>一阶贝塞尔曲线<img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/11.gif" class="" width="300"> </li>
<li>二阶贝塞尔曲线<img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/9.gif" class="" width="300"> </li>
<li>三阶贝塞尔曲线<img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/12.gif" class="" width="300"> </li>
<li>四阶贝塞尔曲线<img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/13.gif" class="" width="300"> </li>
<li>高阶贝塞尔曲线<img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/14.gif" class="" width="300"> </li>
</ul>
<p>如果只是用<code>path</code>画曲线的话，那我们了解到这边就可以了</p>
<h2 id="path画曲线"><a href="#path画曲线" class="headerlink" title="path画曲线"></a>path画曲线</h2><p>通过前面知识我们知道，<code>path</code>中的<code>C</code>命令是三阶需要4个坐标，即开始和结束坐标以及两个控制坐标，<code>Q</code>命令是二阶需要3个坐标，开始结束一个坐标点，<br><code>S</code>命令：当一个点某一侧的控制点是它另外一侧的控制点的对称（以保持斜率不变），可使用<code>S</code>命令。简写的贝塞尔曲线命令。如下图</p>
<img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/15.jpg" class="" width="300"> 
<p><code>T</code>命令：是Q命令的简写命令。<br>与S命令类似，T也会经过前一个控制点，推断出一个新的控制点。<br>（T命令前面必须是一个Q命令，或者是另外一个T命令，才能达到这种效果。若是T单独使用，那么控制点就会被认为和终点是同一个点，因此画出来的将是一条直线。）如下图</p>
<img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/16.png" class="" width="300">
<p>学习完基础知识，我们按照设计稿将曲线画出，大概是这样</p>
<img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/17.jpg" class="">
<p>参考代码</p>
<pre><code class="SVG">        &lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;7.5rem&quot;
            height=&quot;5.8rem&quot; id=&quot;map&quot; viewBox=&quot;0,0,750,580&quot;&gt;
            &lt;path d=&quot;M80,255T126,266&quot; stroke=&quot;#ffb88a&quot; fill=&quot;none&quot; stroke-dasharray=&quot;5&quot; stroke-width=&quot;3&quot; /&gt;
            &lt;path d=&quot;M126,266C207,261 271,220 333,219&quot; stroke=&quot;#ffb88a&quot; fill=&quot;none&quot; stroke-dasharray=&quot;5&quot;
                stroke-width=&quot;3&quot; /&gt;
            &lt;path d=&quot;M333,219C394,348 488,296 537,320&quot; stroke=&quot;#ffb88a&quot; fill=&quot;none&quot; stroke-dasharray=&quot;5&quot;
                stroke-width=&quot;3&quot; /&gt;
            &lt;path d=&quot;M537,320C465,490 680,384 410,556&quot; stroke=&quot;#ffb88a&quot; fill=&quot;none&quot; stroke-dasharray=&quot;5&quot;
                stroke-width=&quot;3&quot; /&gt;
            &lt;path d=&quot;M410,556Q267,526 208,546&quot; stroke=&quot;#ffb88a&quot; fill=&quot;none&quot; stroke-dasharray=&quot;5&quot; stroke-width=&quot;3&quot; /&gt;
            &lt;path d=&quot;M208,546Q147,556 75,522&quot; stroke=&quot;#ffb88a&quot; fill=&quot;none&quot; stroke-dasharray=&quot;5&quot; stroke-width=&quot;3&quot; /&gt;
            &lt;circle cx=&quot;126&quot; cy=&quot;266&quot; r=&quot;15&quot; fill=&quot;#ffb88a&quot; /&gt;
            &lt;text x=&quot;126&quot; y=&quot;266 &quot; fill=&quot;#e76f4e&quot; font-size=&quot;22&quot;&gt;1&lt;/text&gt;
            &lt;circle cx=&quot;333&quot; cy=&quot;219&quot; r=&quot;15&quot; fill=&quot;#ffb88a&quot; /&gt;
            &lt;text x=&quot;333&quot; y=&quot;219 &quot; fill=&quot;#e76f4e&quot; font-size=&quot;22&quot;&gt;2&lt;/text&gt;
            &lt;circle cx=&quot;537&quot; cy=&quot;320&quot; r=&quot;15&quot; fill=&quot;#ffb88a&quot; /&gt;
            &lt;text x=&quot;537&quot; y=&quot;320 &quot; fill=&quot;#e76f4e&quot; font-size=&quot;22&quot;&gt;3&lt;/text&gt;
            &lt;circle cx=&quot;410&quot; cy=&quot;556&quot; r=&quot;15&quot; fill=&quot;#ffb88a&quot; /&gt;
            &lt;text x=&quot;410&quot; y=&quot;556 &quot; fill=&quot;#e76f4e&quot; font-size=&quot;22&quot;&gt;4&lt;/text&gt;
            &lt;circle cx=&quot;208&quot; cy=&quot;546&quot; r=&quot;15&quot; fill=&quot;#ffb88a&quot; /&gt;
            &lt;text x=&quot;208&quot; y=&quot;546 &quot; fill=&quot;#e76f4e&quot; font-size=&quot;22&quot;&gt;5&lt;/text&gt;
        &lt;/svg&gt;
</code></pre>
<p>运动小车是绝对定位和svg中点坐标一致</p>
<h2 id="曲线运动"><a href="#曲线运动" class="headerlink" title="曲线运动"></a>曲线运动</h2><p>接下来要让小车动起来，原先的js写法是不行了，我们要用到svg的DOM接口，主要有</p>
<ul>
<li>getTotalLength() 获取path的总长度</li>
<li>getPointAtLength() 根据长度获取线上的点<br>这样我们就可以递增长度获取运动点，让元素沿曲线运动起来,参考代码<pre><code class="javascript">function moveNext(selector, paths) &#123;
var el = $(selector);
if (!el.length) &#123;
  throw new Error(&quot;selector: &#39;&quot; + selector + &quot;&#39; no find!&quot;);
&#125;
if (!paths.length) return;
if (!paths.current &amp;&amp; paths.current != 0) &#123;
  paths.current = 0;
&#125;
var p = paths[paths.current];
paths.current = ++paths.current % paths.length;
var step = 0;
var move = function () &#123;
  step += 0.03;
  if (step &gt;= 1) &#123;
    if (p.next) &#123; 
      moveNext(selector, paths);
    &#125; else &#123;
      el.css(&quot;pointer-events&quot;, &quot;initial&quot;);
    &#125;
    return;
  &#125;
  var nextpoint = p.getPointAtLength(step * p.getTotalLength());
  el.css(&quot;pointer-events&quot;, &quot;none&quot;);
  el.css(&#123;
    left: (nextpoint.x / 100).toFixed(2) + &quot;rem&quot;,
    top: (nextpoint.y / 100).toFixed(2) + &quot;rem&quot;,
  &#125;);
  //DOM帧回调
  requestAnimationFrame(move);
&#125;;
requestAnimationFrame(move);
&#125;
</code></pre>
上面用<code>requestAnimationFrame</code>优化了<code>setTimeout</code>,<code>requestAnimationFrame</code>相比<code>setTimeout</code>、<code>setInterval</code>优势有</li>
<li>requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li>
<li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量</li>
</ul>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><img src="/2022/04/12/svg%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/18.gif" class="">
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
</search>
